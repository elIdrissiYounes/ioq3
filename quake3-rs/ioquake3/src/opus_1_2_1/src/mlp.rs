// =============== BEGIN mlp_h ================
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MLP {
    pub layers: i32,
    pub topo: *const i32,
    pub weights: *const f32,
}

pub mod arch_h {

    /* This code should reliably detect NaN/inf even when -ffast-math is used.
    Assumes IEEE 754 format. */
    #[inline]

    pub unsafe extern "C" fn celt_isnan(mut x: f32) -> i32 {
        let mut in_0: crate::mathops_h::C2RustUnnamed_61 =
            crate::mathops_h::C2RustUnnamed_61 { f: 0. };
        in_0.f = x;
        return (in_0.i >> 23 & 0xff == 0xff && in_0.i & 0x7fffff != 0) as i32;
    }

    /* ARCH_H */
    /* !FIXED_POINT */
    /* This appears to be the same speed as C99's fabsf() but it's more portable. */
}

pub mod tansig_table_h {
    /* This file is auto-generated by gen_tables */

    pub static mut tansig_table: [f32; 201] = [
        0.000000, 0.039979, 0.079830, 0.119427, 0.158649, 0.197375, 0.235496, 0.272905, 0.309507,
        0.345214, 0.379949, 0.413644, 0.446244, 0.477700, 0.507977, 0.537050, 0.564900, 0.591519,
        0.616909, 0.641077, 0.664037, 0.685809, 0.706419, 0.725897, 0.744277, 0.761594, 0.777888,
        0.793199, 0.807569, 0.821040, 0.833655, 0.845456, 0.856485, 0.866784, 0.876393, 0.885352,
        0.893698, 0.901468, 0.908698, 0.915420, 0.921669, 0.927473, 0.932862, 0.937863, 0.942503,
        0.946806, 0.950795, 0.954492, 0.957917, 0.961090, 0.964028, 0.966747, 0.969265, 0.971594,
        0.973749, 0.975743, 0.977587, 0.979293, 0.980869, 0.982327, 0.983675, 0.984921, 0.986072,
        0.987136, 0.988119, 0.989027, 0.989867, 0.990642, 0.991359, 0.992020, 0.992631, 0.993196,
        0.993718, 0.994199, 0.994644, 0.995055, 0.995434, 0.995784, 0.996108, 0.996407, 0.996682,
        0.996937, 0.997172, 0.997389, 0.997590, 0.997775, 0.997946, 0.998104, 0.998249, 0.998384,
        0.998508, 0.998623, 0.998728, 0.998826, 0.998916, 0.999000, 0.999076, 0.999147, 0.999213,
        0.999273, 0.999329, 0.999381, 0.999428, 0.999472, 0.999513, 0.999550, 0.999585, 0.999617,
        0.999646, 0.999673, 0.999699, 0.999722, 0.999743, 0.999763, 0.999781, 0.999798, 0.999813,
        0.999828, 0.999841, 0.999853, 0.999865, 0.999875, 0.999885, 0.999893, 0.999902, 0.999909,
        0.999916, 0.999923, 0.999929, 0.999934, 0.999939, 0.999944, 0.999948, 0.999952, 0.999956,
        0.999959, 0.999962, 0.999965, 0.999968, 0.999970, 0.999973, 0.999975, 0.999977, 0.999978,
        0.999980, 0.999982, 0.999983, 0.999984, 0.999986, 0.999987, 0.999988, 0.999989, 0.999990,
        0.999990, 0.999991, 0.999992, 0.999992, 0.999993, 0.999994, 0.999994, 0.999994, 0.999995,
        0.999995, 0.999996, 0.999996, 0.999996, 0.999997, 0.999997, 0.999997, 0.999997, 0.999997,
        0.999998, 0.999998, 0.999998, 0.999998, 0.999998, 0.999998, 0.999999, 0.999999, 0.999999,
        0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999,
        0.999999, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000,
        1.000000, 1.000000, 1.000000,
    ];
}
pub use crate::opus_types_h::opus_uint32;
pub use crate::stdlib::__uint32_t;
pub use crate::stdlib::uint32_t;

pub use crate::mathops_h::C2RustUnnamed_61;
pub use crate::src::opus_1_2_1::src::mlp::arch_h::celt_isnan;
pub use crate::src::opus_1_2_1::src::mlp::tansig_table_h::tansig_table;

/* Copyright (c) 2008-2011 Octasic Inc.
Written by Jean-Marc Valin */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*extern const float tansig_table[501];*/
#[inline]

unsafe extern "C" fn tansig_approx(mut x: f32) -> f32 {
    let mut i: i32 = 0;
    let mut y: f32 = 0.;
    let mut dy: f32 = 0.;
    let mut sign: f32 = 1f32;
    /* Tests are reversed to catch NaNs */
    if !(x < 8f32) {
        return 1f32;
    }
    if !(x > -8f32) {
        return -1f32;
    }
    /* Another check in case of -ffast-math */
    if celt_isnan(x) != 0 {
        return 0f32;
    }
    if x < 0f32 {
        x = -x;
        sign = -1f32
    }
    i = crate::stdlib::floor((0.5f32 + 25f32 * x) as f64) as i32;
    x -= 0.04 * i as f32;
    y = tansig_table[i as usize];
    dy = 1f32 - y * y;
    y = y + x * dy * (1f32 - y * x);
    return sign * y;
}
#[no_mangle]

pub unsafe extern "C" fn mlp_process(
    mut m: *const crate::src::opus_1_2_1::src::mlp::MLP,
    mut in_0: *const f32,
    mut out: *mut f32,
) {
    let mut j: i32 = 0;
    let mut hidden: [f32; 100] = [0.; 100];
    let mut W: *const f32 = (*m).weights;
    /* Copy to tmp_in */
    j = 0;
    while j < *(*m).topo.offset(1) {
        let mut _k: i32 = 0;
        let fresh0 = W;
        W = W.offset(1);
        let mut sum: f32 = *fresh0;

        for k in 0..*(*m).topo.offset(0) {
            let fresh1 = W;

            W = W.offset(1);

            sum = sum + *in_0.offset(k as isize) * *fresh1;
        }
        hidden[j as usize] = tansig_approx(sum);
        j += 1
    }
    j = 0;
    while j < *(*m).topo.offset(2) {
        let mut _k_0: i32 = 0;
        let fresh2 = W;
        W = W.offset(1);
        let mut sum_0: f32 = *fresh2;

        for k_0 in 0..*(*m).topo.offset(1) {
            let fresh3 = W;

            W = W.offset(1);

            sum_0 = sum_0 + hidden[k_0 as usize] * *fresh3;
        }
        *out.offset(j as isize) = tansig_approx(sum_0);
        j += 1
    }
}
