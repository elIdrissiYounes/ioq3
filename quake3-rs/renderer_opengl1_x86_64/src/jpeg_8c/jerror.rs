// =============== BEGIN jerror_h ================
pub type C2RustUnnamed_1 = u32;

pub const JERR_BAD_STRUCT_SIZE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 22;

pub const JERR_BAD_LIB_VERSION: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 13;

pub const JERR_CANT_SUSPEND: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 25;

pub const JERR_BAD_STATE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 21;

pub const JERR_TOO_LITTLE_DATA: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 69;

pub const JMSG_LASTMSGCODE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 127;

pub const JWRN_TOO_MUCH_DATA: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 126;

pub const JWRN_NOT_SEQUENTIAL: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 125;

pub const JWRN_MUST_RESYNC: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 124;

pub const JWRN_JPEG_EOF: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 123;

pub const JWRN_JFIF_MAJOR: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 122;

pub const JWRN_HUFF_BAD_CODE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 121;

pub const JWRN_HIT_MARKER: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 120;

pub const JWRN_EXTRANEOUS_DATA: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 119;

pub const JWRN_BOGUS_PROGRESSION: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 118;

pub const JWRN_ARITH_BAD_CODE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 117;

pub const JWRN_ADOBE_XFORM: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 116;

pub const JTRC_XMS_OPEN: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 115;

pub const JTRC_XMS_CLOSE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 114;

pub const JTRC_UNKNOWN_IDS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 113;

pub const JTRC_THUMB_RGB: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 112;

pub const JTRC_THUMB_PALETTE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 111;

pub const JTRC_THUMB_JPEG: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 110;

pub const JTRC_TFILE_OPEN: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 109;

pub const JTRC_TFILE_CLOSE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 108;

pub const JTRC_SOS_PARAMS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 107;

pub const JTRC_SOS_COMPONENT: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 106;

pub const JTRC_SOS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 105;

pub const JTRC_SOI: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 104;

pub const JTRC_SOF_COMPONENT: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 103;

pub const JTRC_SOF: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 102;

pub const JTRC_SMOOTH_NOTIMPL: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 101;

pub const JTRC_RST: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 100;

pub const JTRC_RECOVERY_ACTION: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 99;

pub const JTRC_QUANT_SELECTED: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 98;

pub const JTRC_QUANT_NCOLORS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 97;

pub const JTRC_QUANT_3_NCOLORS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 96;

pub const JTRC_QUANTVALS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 95;

pub const JTRC_PARMLESS_MARKER: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 94;

pub const JTRC_MISC_MARKER: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 93;

pub const JTRC_JFIF_THUMBNAIL: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 92;

pub const JTRC_JFIF_EXTENSION: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 91;

pub const JTRC_JFIF_BADTHUMBNAILSIZE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 90;

pub const JTRC_JFIF: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 89;

pub const JTRC_HUFFBITS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 88;

pub const JTRC_EOI: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 87;

pub const JTRC_EMS_OPEN: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 86;

pub const JTRC_EMS_CLOSE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 85;

pub const JTRC_DRI: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 84;

pub const JTRC_DQT: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 83;

pub const JTRC_DHT: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 82;

pub const JTRC_DAC: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 81;

pub const JTRC_APP14: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 80;

pub const JTRC_APP0: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 79;

pub const JTRC_ADOBE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 78;

pub const JTRC_16BIT_TABLES: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 77;

pub const JMSG_VERSION: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 76;

pub const JMSG_COPYRIGHT: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 75;

pub const JERR_XMS_WRITE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 74;

pub const JERR_XMS_READ: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 73;

pub const JERR_WIDTH_OVERFLOW: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 72;

pub const JERR_VIRTUAL_BUG: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 71;

pub const JERR_UNKNOWN_MARKER: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 70;

pub const JERR_TFILE_WRITE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 68;

pub const JERR_TFILE_SEEK: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 67;

pub const JERR_TFILE_READ: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 66;

pub const JERR_TFILE_CREATE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 65;

pub const JERR_SOS_NO_SOF: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 64;

pub const JERR_SOI_DUPLICATE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 63;

pub const JERR_SOF_UNSUPPORTED: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 62;

pub const JERR_SOF_NO_SOS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 61;

pub const JERR_SOF_DUPLICATE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 60;

pub const JERR_QUANT_MANY_COLORS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 59;

pub const JERR_QUANT_FEW_COLORS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 58;

pub const JERR_QUANT_COMPONENTS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 57;

pub const JERR_OUT_OF_MEMORY: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 56;

pub const JERR_NO_SOI: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 55;

pub const JERR_NO_QUANT_TABLE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 54;

pub const JERR_NO_IMAGE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 53;

pub const JERR_NO_HUFF_TABLE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 52;

pub const JERR_NO_BACKING_STORE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 51;

pub const JERR_NO_ARITH_TABLE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 50;

pub const JERR_NOT_COMPILED: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 49;

pub const JERR_NOTIMPL: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 48;

pub const JERR_MODE_CHANGE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 47;

pub const JERR_MISSING_DATA: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 46;

pub const JERR_MISMATCHED_QUANT_TABLE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 45;

pub const JERR_INPUT_EOF: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 44;

pub const JERR_INPUT_EMPTY: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 43;

pub const JERR_IMAGE_TOO_BIG: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 42;

pub const JERR_HUFF_MISSING_CODE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 41;

pub const JERR_HUFF_CLEN_OVERFLOW: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 40;

pub const JERR_FRACT_SAMPLE_NOTIMPL: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 39;

pub const JERR_FILE_WRITE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 38;

pub const JERR_FILE_READ: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 37;

pub const JERR_EOI_EXPECTED: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 36;

pub const JERR_EMS_WRITE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 35;

pub const JERR_EMS_READ: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 34;

pub const JERR_EMPTY_IMAGE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 33;

pub const JERR_DQT_INDEX: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 32;

pub const JERR_DHT_INDEX: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 31;

pub const JERR_DAC_VALUE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 30;

pub const JERR_DAC_INDEX: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 29;

pub const JERR_CONVERSION_NOTIMPL: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 28;

pub const JERR_COMPONENT_COUNT: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 27;

pub const JERR_CCIR601_NOTIMPL: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 26;

pub const JERR_BUFFER_SIZE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 24;

pub const JERR_BAD_VIRTUAL_ACCESS: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 23;

pub const JERR_BAD_SCAN_SCRIPT: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 20;

pub const JERR_BAD_SAMPLING: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 19;

pub const JERR_BAD_PROG_SCRIPT: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 18;

pub const JERR_BAD_PROGRESSION: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 17;

pub const JERR_BAD_PRECISION: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 16;

pub const JERR_BAD_POOL_ID: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 15;

pub const JERR_BAD_MCU_SIZE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 14;

pub const JERR_BAD_LENGTH: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 12;

pub const JERR_BAD_J_COLORSPACE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 11;

pub const JERR_BAD_IN_COLORSPACE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 10;

pub const JERR_BAD_HUFF_TABLE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 9;

pub const JERR_BAD_DROP_SAMPLING: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 8;

pub const JERR_BAD_DCTSIZE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 7;

pub const JERR_BAD_DCT_COEF: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 6;

pub const JERR_BAD_CROP_SPEC: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 5;

pub const JERR_BAD_COMPONENT_ID: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 4;

pub const JERR_BAD_BUFFER_MODE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 3;

pub const JERR_BAD_ALLOC_CHUNK: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 2;

pub const JERR_BAD_ALIGN_TYPE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 1;

pub const JMSG_NOMESSAGE: crate::src::jpeg_8c::jerror::C2RustUnnamed_1 = 0;
use ::libc;

pub use crate::stddef_h::size_t;

pub use crate::stdlib::_IO_codecvt;
pub use crate::stdlib::_IO_lock_t;
pub use crate::stdlib::_IO_marker;
pub use crate::stdlib::_IO_wide_data;
pub use crate::stdlib::__off64_t;
pub use crate::stdlib::__off_t;
pub use crate::stdlib::FILE;
pub use crate::stdlib::_IO_FILE;

pub use crate::jmorecfg_h::boolean;
pub use crate::jmorecfg_h::JCOEF;
pub use crate::jmorecfg_h::JDIMENSION;
pub use crate::jmorecfg_h::JSAMPLE;
pub use crate::jpeglib_h::j_common_ptr;
pub use crate::jpeglib_h::jpeg_common_struct;
pub use crate::jpeglib_h::jpeg_error_mgr;
pub use crate::jpeglib_h::jpeg_memory_mgr;
pub use crate::jpeglib_h::jpeg_progress_mgr;
pub use crate::jpeglib_h::jvirt_barray_control;
pub use crate::jpeglib_h::jvirt_barray_ptr;
pub use crate::jpeglib_h::jvirt_sarray_control;
pub use crate::jpeglib_h::jvirt_sarray_ptr;
pub use crate::jpeglib_h::C2RustUnnamed_0;
pub use crate::jpeglib_h::JBLOCK;
pub use crate::jpeglib_h::JBLOCKARRAY;
pub use crate::jpeglib_h::JBLOCKROW;
pub use crate::jpeglib_h::JSAMPARRAY;
pub use crate::jpeglib_h::JSAMPROW;
pub use crate::src::jpeg_8c::jcomapi::jpeg_destroy;
use crate::stdlib::exit;
use crate::stdlib::fprintf;
use crate::stdlib::sprintf;
use crate::stdlib::stderr;
/*
 * jerror.c
 *
 * Copyright (C) 1991-1998, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains simple error-reporting and trace-message routines.
 * These are suitable for Unix-like systems and others where writing to
 * stderr is the right thing to do.  Many applications will want to replace
 * some or all of these routines.
 *
 * If you define USE_WINDOWS_MESSAGEBOX in jconfig.h or in the makefile,
 * you get a Windows-specific hack to display error messages in a dialog box.
 * It ain't much, but it beats dropping error messages into the bit bucket,
 * which is what happens to output to stderr under most Windows C compilers.
 *
 * These routines are used by both the compression and decompression code.
 */
/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
/* define exit() codes if not provided */
/*
 * Create the message string table.
 * We do this from the master message list in jerror.h by re-reading
 * jerror.h with a suitable definition for macro JMESSAGE.
 * The message table is made an external symbol just in case any applications
 * want to refer to it directly.
 */
#[no_mangle]

pub static mut jpeg_std_message_table: [*const i8; 128] = [
    b"Bogus message code %d\x00" as *const u8 as *const i8,
    b"ALIGN_TYPE is wrong, please fix\x00" as *const u8 as *const i8,
    b"MAX_ALLOC_CHUNK is wrong, please fix\x00" as *const u8 as *const i8,
    b"Bogus buffer control mode\x00" as *const u8 as *const i8,
    b"Invalid component ID %d in SOS\x00" as *const u8 as *const i8,
    b"Invalid crop request\x00" as *const u8 as *const i8,
    b"DCT coefficient out of range\x00" as *const u8 as *const i8,
    b"DCT scaled block size %dx%d not supported\x00" as *const u8 as *const i8,
    b"Component index %d: mismatching sampling ratio %d:%d, %d:%d, %c\x00" as *const u8
        as *const i8,
    b"Bogus Huffman table definition\x00" as *const u8 as *const i8,
    b"Bogus input colorspace\x00" as *const u8 as *const i8,
    b"Bogus JPEG colorspace\x00" as *const u8 as *const i8,
    b"Bogus marker length\x00" as *const u8 as *const i8,
    b"Wrong JPEG library version: library is %d, caller expects %d\x00" as *const u8 as *const i8,
    b"Sampling factors too large for interleaved scan\x00" as *const u8 as *const i8,
    b"Invalid memory pool code %d\x00" as *const u8 as *const i8,
    b"Unsupported JPEG data precision %d\x00" as *const u8 as *const i8,
    b"Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d\x00" as *const u8 as *const i8,
    b"Invalid progressive parameters at scan script entry %d\x00" as *const u8 as *const i8,
    b"Bogus sampling factors\x00" as *const u8 as *const i8,
    b"Invalid scan script at entry %d\x00" as *const u8 as *const i8,
    b"Improper call to JPEG library in state %d\x00" as *const u8 as *const i8,
    b"JPEG parameter struct mismatch: library thinks size is %u, caller expects %u\x00" as *const u8
        as *const i8,
    b"Bogus virtual array access\x00" as *const u8 as *const i8,
    b"Buffer passed to JPEG library is too small\x00" as *const u8 as *const i8,
    b"Suspension not allowed here\x00" as *const u8 as *const i8,
    b"CCIR601 sampling not implemented yet\x00" as *const u8 as *const i8,
    b"Too many color components: %d, max %d\x00" as *const u8 as *const i8,
    b"Unsupported color conversion request\x00" as *const u8 as *const i8,
    b"Bogus DAC index %d\x00" as *const u8 as *const i8,
    b"Bogus DAC value 0x%x\x00" as *const u8 as *const i8,
    b"Bogus DHT index %d\x00" as *const u8 as *const i8,
    b"Bogus DQT index %d\x00" as *const u8 as *const i8,
    b"Empty JPEG image (DNL not supported)\x00" as *const u8 as *const i8,
    b"Read from EMS failed\x00" as *const u8 as *const i8,
    b"Write to EMS failed\x00" as *const u8 as *const i8,
    b"Didn\'t expect more than one scan\x00" as *const u8 as *const i8,
    b"Input file read error\x00" as *const u8 as *const i8,
    b"Output file write error --- out of disk space?\x00" as *const u8 as *const i8,
    b"Fractional sampling not implemented yet\x00" as *const u8 as *const i8,
    b"Huffman code size table overflow\x00" as *const u8 as *const i8,
    b"Missing Huffman code table entry\x00" as *const u8 as *const i8,
    b"Maximum supported image dimension is %u pixels\x00" as *const u8 as *const i8,
    b"Empty input file\x00" as *const u8 as *const i8,
    b"Premature end of input file\x00" as *const u8 as *const i8,
    b"Cannot transcode due to multiple use of quantization table %d\x00" as *const u8 as *const i8,
    b"Scan script does not transmit all data\x00" as *const u8 as *const i8,
    b"Invalid color quantization mode change\x00" as *const u8 as *const i8,
    b"Not implemented yet\x00" as *const u8 as *const i8,
    b"Requested feature was omitted at compile time\x00" as *const u8 as *const i8,
    b"Arithmetic table 0x%02x was not defined\x00" as *const u8 as *const i8,
    b"Backing store not supported\x00" as *const u8 as *const i8,
    b"Huffman table 0x%02x was not defined\x00" as *const u8 as *const i8,
    b"JPEG datastream contains no image\x00" as *const u8 as *const i8,
    b"Quantization table 0x%02x was not defined\x00" as *const u8 as *const i8,
    b"Not a JPEG file: starts with 0x%02x 0x%02x\x00" as *const u8 as *const i8,
    b"Insufficient memory (case %d)\x00" as *const u8 as *const i8,
    b"Cannot quantize more than %d color components\x00" as *const u8 as *const i8,
    b"Cannot quantize to fewer than %d colors\x00" as *const u8 as *const i8,
    b"Cannot quantize to more than %d colors\x00" as *const u8 as *const i8,
    b"Invalid JPEG file structure: two SOF markers\x00" as *const u8 as *const i8,
    b"Invalid JPEG file structure: missing SOS marker\x00" as *const u8 as *const i8,
    b"Unsupported JPEG process: SOF type 0x%02x\x00" as *const u8 as *const i8,
    b"Invalid JPEG file structure: two SOI markers\x00" as *const u8 as *const i8,
    b"Invalid JPEG file structure: SOS before SOF\x00" as *const u8 as *const i8,
    b"Failed to create temporary file %s\x00" as *const u8 as *const i8,
    b"Read failed on temporary file\x00" as *const u8 as *const i8,
    b"Seek failed on temporary file\x00" as *const u8 as *const i8,
    b"Write failed on temporary file --- out of disk space?\x00" as *const u8 as *const i8,
    b"Application transferred too few scanlines\x00" as *const u8 as *const i8,
    b"Unsupported marker type 0x%02x\x00" as *const u8 as *const i8,
    b"Virtual array controller messed up\x00" as *const u8 as *const i8,
    b"Image too wide for this implementation\x00" as *const u8 as *const i8,
    b"Read from XMS failed\x00" as *const u8 as *const i8,
    b"Write to XMS failed\x00" as *const u8 as *const i8,
    b"Copyright (C) 2011, Thomas G. Lane, Guido Vollbeding\x00" as *const u8 as *const i8,
    b"8c  16-Jan-2011\x00" as *const u8 as *const i8,
    b"Caution: quantization tables are too coarse for baseline JPEG\x00" as *const u8 as *const i8,
    b"Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d\x00" as *const u8
        as *const i8,
    b"Unknown APP0 marker (not JFIF), length %u\x00" as *const u8 as *const i8,
    b"Unknown APP14 marker (not Adobe), length %u\x00" as *const u8 as *const i8,
    b"Define Arithmetic Table 0x%02x: 0x%02x\x00" as *const u8 as *const i8,
    b"Define Huffman Table 0x%02x\x00" as *const u8 as *const i8,
    b"Define Quantization Table %d  precision %d\x00" as *const u8 as *const i8,
    b"Define Restart Interval %u\x00" as *const u8 as *const i8,
    b"Freed EMS handle %u\x00" as *const u8 as *const i8,
    b"Obtained EMS handle %u\x00" as *const u8 as *const i8,
    b"End Of Image\x00" as *const u8 as *const i8,
    b"        %3d %3d %3d %3d %3d %3d %3d %3d\x00" as *const u8 as *const i8,
    b"JFIF APP0 marker: version %d.%02d, density %dx%d  %d\x00" as *const u8 as *const i8,
    b"Warning: thumbnail image size does not match data length %u\x00" as *const u8 as *const i8,
    b"JFIF extension marker: type 0x%02x, length %u\x00" as *const u8 as *const i8,
    b"    with %d x %d thumbnail image\x00" as *const u8 as *const i8,
    b"Miscellaneous marker 0x%02x, length %u\x00" as *const u8 as *const i8,
    b"Unexpected marker 0x%02x\x00" as *const u8 as *const i8,
    b"        %4u %4u %4u %4u %4u %4u %4u %4u\x00" as *const u8 as *const i8,
    b"Quantizing to %d = %d*%d*%d colors\x00" as *const u8 as *const i8,
    b"Quantizing to %d colors\x00" as *const u8 as *const i8,
    b"Selected %d colors for quantization\x00" as *const u8 as *const i8,
    b"At marker 0x%02x, recovery action %d\x00" as *const u8 as *const i8,
    b"RST%d\x00" as *const u8 as *const i8,
    b"Smoothing not supported with nonstandard sampling ratios\x00" as *const u8 as *const i8,
    b"Start Of Frame 0x%02x: width=%u, height=%u, components=%d\x00" as *const u8 as *const i8,
    b"    Component %d: %dhx%dv q=%d\x00" as *const u8 as *const i8,
    b"Start of Image\x00" as *const u8 as *const i8,
    b"Start Of Scan: %d components\x00" as *const u8 as *const i8,
    b"    Component %d: dc=%d ac=%d\x00" as *const u8 as *const i8,
    b"  Ss=%d, Se=%d, Ah=%d, Al=%d\x00" as *const u8 as *const i8,
    b"Closed temporary file %s\x00" as *const u8 as *const i8,
    b"Opened temporary file %s\x00" as *const u8 as *const i8,
    b"JFIF extension marker: JPEG-compressed thumbnail image, length %u\x00" as *const u8
        as *const i8,
    b"JFIF extension marker: palette thumbnail image, length %u\x00" as *const u8 as *const i8,
    b"JFIF extension marker: RGB thumbnail image, length %u\x00" as *const u8 as *const i8,
    b"Unrecognized component IDs %d %d %d, assuming YCbCr\x00" as *const u8 as *const i8,
    b"Freed XMS handle %u\x00" as *const u8 as *const i8,
    b"Obtained XMS handle %u\x00" as *const u8 as *const i8,
    b"Unknown Adobe color transform code %d\x00" as *const u8 as *const i8,
    b"Corrupt JPEG data: bad arithmetic code\x00" as *const u8 as *const i8,
    b"Inconsistent progression sequence for component %d coefficient %d\x00" as *const u8
        as *const i8,
    b"Corrupt JPEG data: %u extraneous bytes before marker 0x%02x\x00" as *const u8 as *const i8,
    b"Corrupt JPEG data: premature end of data segment\x00" as *const u8 as *const i8,
    b"Corrupt JPEG data: bad Huffman code\x00" as *const u8 as *const i8,
    b"Warning: unknown JFIF revision number %d.%02d\x00" as *const u8 as *const i8,
    b"Premature end of JPEG file\x00" as *const u8 as *const i8,
    b"Corrupt JPEG data: found marker 0x%02x instead of RST%d\x00" as *const u8 as *const i8,
    b"Invalid SOS parameters for sequential JPEG\x00" as *const u8 as *const i8,
    b"Application transferred too many scanlines\x00" as *const u8 as *const i8,
    0 as *const i8,
];
/*
 * Error exit handler: must not return to caller.
 *
 * Applications may override this if they want to get control back after
 * an error.  Typically one would longjmp somewhere instead of exiting.
 * The setjmp buffer can be made a private field within an expanded error
 * handler object.  Note that the info needed to generate an error message
 * is stored in the error object, so you can generate the message now or
 * later, at your convenience.
 * You should make sure that the JPEG object is cleaned up (with jpeg_abort
 * or jpeg_destroy) at some point.
 */

unsafe extern "C" fn error_exit(mut cinfo: crate::jpeglib_h::j_common_ptr) {
    /* Always display the message */
    Some(
        (*(*cinfo).err)
            .output_message
            .expect("non-null function pointer"),
    )
    .expect("non-null function pointer")(cinfo);
    /* Let the memory manager delete any temp files before we die */
    crate::src::jpeg_8c::jcomapi::jpeg_destroy(cinfo);
    crate::stdlib::exit(1);
}
/*
 * Actual output of an error or trace message.
 * Applications may override this method to send JPEG messages somewhere
 * other than stderr.
 *
 * On Windows, printing to stderr is generally completely useless,
 * so we provide optional code to produce an error-dialog popup.
 * Most Windows applications will still prefer to override this routine,
 * but if they don't, it'll do something at least marginally useful.
 *
 * NOTE: to use the library in an environment that doesn't support the
 * C stdio library, you may have to delete the call to fprintf() entirely,
 * not just not use this routine.
 */

unsafe extern "C" fn output_message(mut cinfo: crate::jpeglib_h::j_common_ptr) {
    let mut buffer: [i8; 200] = [0; 200];
    /* Create the message */
    Some(
        (*(*cinfo).err)
            .format_message
            .expect("non-null function pointer"),
    )
    .expect("non-null function pointer")(cinfo, buffer.as_mut_ptr());
    /* Send it to stderr, adding a newline */
    crate::stdlib::fprintf(
        crate::stdlib::stderr,
        b"%s\n\x00" as *const u8 as *const i8,
        buffer.as_mut_ptr(),
    );
}
/*
 * Decide whether to emit a trace or warning message.
 * msg_level is one of:
 *   -1: recoverable corrupt-data warning, may want to abort.
 *    0: important advisory messages (always display to user).
 *    1: first level of tracing detail.
 *    2,3,...: successively more detailed tracing messages.
 * An application might override this method if it wanted to abort on warnings
 * or change the policy about which messages to display.
 */

unsafe extern "C" fn emit_message(mut cinfo: crate::jpeglib_h::j_common_ptr, mut msg_level: i32) {
    let mut err: *mut crate::jpeglib_h::jpeg_error_mgr = (*cinfo).err;
    if msg_level < 0 {
        /* It's a warning message.  Since corrupt files may generate many warnings,
         * the policy implemented here is to show only the first warning,
         * unless trace_level >= 3.
         */
        if (*err).num_warnings == 0 || (*err).trace_level >= 3 {
            Some((*err).output_message.expect("non-null function pointer"))
                .expect("non-null function pointer")(cinfo);
        }
        /* Always count warnings in num_warnings. */
        (*err).num_warnings += 1
    } else if (*err).trace_level >= msg_level {
        Some((*err).output_message.expect("non-null function pointer"))
            .expect("non-null function pointer")(cinfo);
    };
}
/* It's a trace message.  Show it if trace_level >= msg_level. */
/*
 * Format a message string for the most recent JPEG error or message.
 * The message is stored into buffer, which should be at least JMSG_LENGTH_MAX
 * characters.  Note that no '\n' character is added to the string.
 * Few applications should need to override this method.
 */

unsafe extern "C" fn format_message(
    mut cinfo: crate::jpeglib_h::j_common_ptr,
    mut buffer: *mut i8,
) {
    let mut err: *mut crate::jpeglib_h::jpeg_error_mgr = (*cinfo).err;
    let mut msg_code: i32 = (*err).msg_code;
    let mut msgtext: *const i8 = 0 as *const i8;
    let mut msgptr: *const i8 = 0 as *const i8;
    let mut ch: i8 = 0;
    let mut isstring: crate::jmorecfg_h::boolean = 0;
    /* Look up message string in proper table */
    if msg_code > 0 && msg_code <= (*err).last_jpeg_message {
        msgtext = *(*err).jpeg_message_table.offset(msg_code as isize)
    } else if !(*err).addon_message_table.is_null()
        && msg_code >= (*err).first_addon_message
        && msg_code <= (*err).last_addon_message
    {
        msgtext = *(*err)
            .addon_message_table
            .offset((msg_code - (*err).first_addon_message) as isize)
    }
    /* Defend against bogus message number */
    if msgtext.is_null() {
        (*err).msg_parm.i[0] = msg_code;
        msgtext = *(*err).jpeg_message_table.offset(0)
    }
    /* Check for string parameter, as indicated by %s in the message text */
    isstring = 0;
    msgptr = msgtext;
    loop {
        let fresh0 = msgptr;
        msgptr = msgptr.offset(1);
        ch = *fresh0;
        if !(ch as i32 != '\u{0}' as i32) {
            break;
        }
        if !(ch as i32 == '%' as i32) {
            continue;
        }
        if *msgptr as i32 == 's' as i32 {
            isstring = 1
        }
        break;
    }
    /* Format the message into the passed buffer */
    if isstring != 0 {
        crate::stdlib::sprintf(buffer, msgtext, (*err).msg_parm.s.as_mut_ptr());
    } else {
        crate::stdlib::sprintf(
            buffer,
            msgtext,
            (*err).msg_parm.i[0usize],
            (*err).msg_parm.i[1usize],
            (*err).msg_parm.i[2usize],
            (*err).msg_parm.i[3usize],
            (*err).msg_parm.i[4usize],
            (*err).msg_parm.i[5usize],
            (*err).msg_parm.i[6usize],
            (*err).msg_parm.i[7usize],
        );
    };
}
/*
 * Reset error state variables at start of a new image.
 * This is called during compression startup to reset trace/error
 * processing to default state, without losing any application-specific
 * method pointers.  An application might possibly want to override
 * this method if it has additional error processing state.
 */

unsafe extern "C" fn reset_error_mgr(mut cinfo: crate::jpeglib_h::j_common_ptr) {
    (*(*cinfo).err).num_warnings = 0isize;
    /* trace_level is not reset since it is an application-supplied parameter */
    (*(*cinfo).err).msg_code = 0;
    /* may be useful as a flag for "no error" */
}
/* Declarations for routines called by application.
 * The JPP macro hides prototype parameters from compilers that can't cope.
 * Note JPP requires double parentheses.
 */
/* Short forms of external names for systems with brain-damaged linkers.
 * We shorten external names to be unique in the first six letters, which
 * is good enough for all known systems.
 * (If your compiler itself needs names to be unique in less than 15
 * characters, you are out of luck.  Get a better compiler.)
 */
/* NEED_SHORT_EXTERNAL_NAMES */
/* Default error-management setup */
/*
 * Fill in the standard error-handling methods in a jpeg_error_mgr object.
 * Typical call is:
 *	struct jpeg_compress_struct cinfo;
 *	struct jpeg_error_mgr err;
 *
 *	cinfo.err = jpeg_std_error(&err);
 * after which the application may override some of the methods.
 */
#[no_mangle]

pub unsafe extern "C" fn jpeg_std_error(
    mut err: *mut crate::jpeglib_h::jpeg_error_mgr,
) -> *mut crate::jpeglib_h::jpeg_error_mgr {
    (*err).error_exit =
        Some(error_exit as unsafe extern "C" fn(_: crate::jpeglib_h::j_common_ptr) -> ()); /* default = no tracing */
    (*err).emit_message =
        Some(emit_message as unsafe extern "C" fn(_: crate::jpeglib_h::j_common_ptr, _: i32) -> ()); /* no warnings emitted yet */
    (*err).output_message =
        Some(output_message as unsafe extern "C" fn(_: crate::jpeglib_h::j_common_ptr) -> ()); /* may be useful as a flag for "no error" */
    (*err).format_message = Some(
        format_message as unsafe extern "C" fn(_: crate::jpeglib_h::j_common_ptr, _: *mut i8) -> (),
    );
    (*err).reset_error_mgr =
        Some(reset_error_mgr as unsafe extern "C" fn(_: crate::jpeglib_h::j_common_ptr) -> ());
    (*err).trace_level = 0;
    (*err).num_warnings = 0isize;
    (*err).msg_code = 0;
    /* Initialize message table pointers */
    (*err).jpeg_message_table = jpeg_std_message_table.as_ptr(); /* for safety */
    (*err).last_jpeg_message = crate::src::jpeg_8c::jerror::JMSG_LASTMSGCODE as i32 - 1;
    (*err).addon_message_table = 0 as *const *const i8;
    (*err).first_addon_message = 0;
    (*err).last_addon_message = 0;
    return err;
}
