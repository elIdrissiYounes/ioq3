use ::libc;

pub mod q_shared_h {

    /*
    ========================================================================

      ELEMENTS COMMUNICATED ACROSS THE NET

    ========================================================================
    */
    // snapshot used during connection and for zombies
    // toggled every map_restart so transitions can be detected
    //
    // per-level limits
    //
    // absolute limit
    // don't need to send any more
    // entitynums are communicated with GENTITY_BITS, so any reserved
    // values that are going to be communcated over the net need to
    // also be in this range
    // these are sent over the net as 8 bits
    // so they cannot be blindly increased
    // these are the only configstrings that the system reserves, all the
    // other ones are strictly for servergame to clientgame communication
    // an info string with all the serverinfo cvars
    // an info string for server system to client system configuration (timescale, etc)
    // game can't modify below this, only the system can
    //=========================================================
    // bit field limits
    // playerState_t is the information needed by both the client and server
    // to predict player motion and actions
    // nothing outside of pmove should modify these, or some degree of prediction error
    // will occur
    // you can't add anything to this without modifying the code in msg.c
    // playerState_t is a full superset of entityState_t as it is used by players,
    // so if a playerState_t is transmitted, the entityState_t can be fully derived
    // from it.
    // cmd->serverTime of last executed command
    // for view bobbing and footstep generation
    // ducked, jump_held, etc
    // add to command angles to get view direction
    // changed by spawns, rotating objects, and teleporters
    // ENTITYNUM_NONE = in air
    // don't change low priority animations until this runs out
    // mask off ANIM_TOGGLEBIT
    // don't change low priority animations until this runs out
    // mask off ANIM_TOGGLEBIT
    // a number 0 to 7 that represents the relative angle
    // of movement to the view angle (axial and diagonals)
    // when at rest, the value will remain unchanged
    // used to twist the legs during strafing
    // location of grapple to pull towards if PMF_GRAPPLE_PULL
    // copied to entityState_t->eFlags
    // pmove generated events
    // events set on player from another source
    // ranges from 0 to MAX_CLIENTS-1
    // copied to entityState_t->weapon
    // for fixed views
    // damage feedback
    // when it changes, latch the other parms
    // stats that aren't cleared on death
    // level.time that the powerup runs out
    // jumppad entity hit this frame
    // not communicated over the net at all
    // server to game info for scoreboard
    //====================================================================
    //
    // usercmd_t->button bits, many of which are generated by the client system,
    // so they aren't game/cgame only definitions
    //
    // displays talk balloon and disables actions
    // walking can't just be inferred from MOVE_RUN
    // because a key pressed late in the frame will
    // only generate a small move value for that frame
    // walking will use different animations and
    // won't generate footsteps
    // any key whatsoever
    // if forwardmove or rightmove are >= MOVE_RUN,
    // then BUTTON_WALKING should be set
    // usercmd_t is sent to the server each client frame

    // weapon
    // entityState_t is the information conveyed from the server
    // in an update message about entities that the client will
    // need to render in some way
    // Different eTypes may use the information in different ways
    // The messages are delta compressed, so it doesn't really matter if
    // the structure size is fairly large

    #[inline]

    pub unsafe extern "C" fn VectorLength(
        mut v: *const crate::src::qcommon::q_shared::vec_t,
    ) -> crate::src::qcommon::q_shared::vec_t {
        return crate::stdlib::sqrt(
            (*v.offset(0 as libc::c_int as isize) * *v.offset(0 as libc::c_int as isize)
                + *v.offset(1 as libc::c_int as isize) * *v.offset(1 as libc::c_int as isize)
                + *v.offset(2 as libc::c_int as isize) * *v.offset(2 as libc::c_int as isize))
                as libc::c_double,
        ) as crate::src::qcommon::q_shared::vec_t;
    }
    use crate::stdlib::sqrt;

    // entity index
    // entityType_t
    // for calculating position
    // for calculating angles
    // shotgun sources, etc
    // ENTITYNUM_NONE = in air
    // r + (g<<8) + (b<<16) + (intensity<<24)
    // constantly loop this sound
    // 0 to (MAX_CLIENTS - 1), for players and corpses
    // for client side prediction, trap_linkentity sets this properly
    // impulse events -- muzzle flashes, footsteps, etc
    // for players
    // bit flags
    // determines weapon and flash model, etc
    // mask off ANIM_TOGGLEBIT
    // mask off ANIM_TOGGLEBIT
    // __Q_SHARED_H
}

pub mod stdlib_h {
    #[inline]

    pub unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
        return ::libc::strtol(
            __nptr,
            0 as *mut libc::c_void as *mut *mut libc::c_char,
            10 as libc::c_int,
        ) as libc::c_int;
    }
}

pub use crate::stddef_h::size_t;

pub use crate::bg_public_h::gitem_s;
pub use crate::bg_public_h::gitem_t;
pub use crate::bg_public_h::itemType_t;
pub use crate::bg_public_h::team_t;
pub use crate::bg_public_h::C2RustUnnamed_0;
pub use crate::bg_public_h::BOTH_DEAD1;
pub use crate::bg_public_h::BOTH_DEAD2;
pub use crate::bg_public_h::BOTH_DEAD3;
pub use crate::bg_public_h::BOTH_DEATH1;
pub use crate::bg_public_h::BOTH_DEATH2;
pub use crate::bg_public_h::BOTH_DEATH3;
pub use crate::bg_public_h::EV_BULLET;
pub use crate::bg_public_h::EV_BULLET_HIT_FLESH;
pub use crate::bg_public_h::EV_BULLET_HIT_WALL;
pub use crate::bg_public_h::EV_CHANGE_WEAPON;
pub use crate::bg_public_h::EV_DEATH1;
pub use crate::bg_public_h::EV_DEATH2;
pub use crate::bg_public_h::EV_DEATH3;
pub use crate::bg_public_h::EV_DEBUG_LINE;
pub use crate::bg_public_h::EV_FALL_FAR;
pub use crate::bg_public_h::EV_FALL_MEDIUM;
pub use crate::bg_public_h::EV_FALL_SHORT;
pub use crate::bg_public_h::EV_FIRE_WEAPON;
pub use crate::bg_public_h::EV_FOOTSPLASH;
pub use crate::bg_public_h::EV_FOOTSTEP;
pub use crate::bg_public_h::EV_FOOTSTEP_METAL;
pub use crate::bg_public_h::EV_FOOTWADE;
pub use crate::bg_public_h::EV_GENERAL_SOUND;
pub use crate::bg_public_h::EV_GIB_PLAYER;
pub use crate::bg_public_h::EV_GLOBAL_ITEM_PICKUP;
pub use crate::bg_public_h::EV_GLOBAL_SOUND;
pub use crate::bg_public_h::EV_GLOBAL_TEAM_SOUND;
pub use crate::bg_public_h::EV_GRENADE_BOUNCE;
pub use crate::bg_public_h::EV_INVUL_IMPACT;
pub use crate::bg_public_h::EV_ITEM_PICKUP;
pub use crate::bg_public_h::EV_ITEM_POP;
pub use crate::bg_public_h::EV_ITEM_RESPAWN;
pub use crate::bg_public_h::EV_JUICED;
pub use crate::bg_public_h::EV_JUMP;
pub use crate::bg_public_h::EV_JUMP_PAD;
pub use crate::bg_public_h::EV_KAMIKAZE;
pub use crate::bg_public_h::EV_LIGHTNINGBOLT;
pub use crate::bg_public_h::EV_MISSILE_HIT;
pub use crate::bg_public_h::EV_MISSILE_MISS;
pub use crate::bg_public_h::EV_MISSILE_MISS_METAL;
pub use crate::bg_public_h::EV_NOAMMO;
pub use crate::bg_public_h::EV_NONE;
pub use crate::bg_public_h::EV_OBELISKEXPLODE;
pub use crate::bg_public_h::EV_OBELISKPAIN;
pub use crate::bg_public_h::EV_OBITUARY;
pub use crate::bg_public_h::EV_PAIN;
pub use crate::bg_public_h::EV_PLAYER_TELEPORT_IN;
pub use crate::bg_public_h::EV_PLAYER_TELEPORT_OUT;
pub use crate::bg_public_h::EV_POWERUP_BATTLESUIT;
pub use crate::bg_public_h::EV_POWERUP_QUAD;
pub use crate::bg_public_h::EV_POWERUP_REGEN;
pub use crate::bg_public_h::EV_PROXIMITY_MINE_STICK;
pub use crate::bg_public_h::EV_PROXIMITY_MINE_TRIGGER;
pub use crate::bg_public_h::EV_RAILTRAIL;
pub use crate::bg_public_h::EV_SCOREPLUM;
pub use crate::bg_public_h::EV_SHOTGUN;
pub use crate::bg_public_h::EV_STEP_12;
pub use crate::bg_public_h::EV_STEP_16;
pub use crate::bg_public_h::EV_STEP_4;
pub use crate::bg_public_h::EV_STEP_8;
pub use crate::bg_public_h::EV_STOPLOOPINGSOUND;
pub use crate::bg_public_h::EV_SWIM;
pub use crate::bg_public_h::EV_TAUNT;
pub use crate::bg_public_h::EV_TAUNT_FOLLOWME;
pub use crate::bg_public_h::EV_TAUNT_GETFLAG;
pub use crate::bg_public_h::EV_TAUNT_GUARDBASE;
pub use crate::bg_public_h::EV_TAUNT_NO;
pub use crate::bg_public_h::EV_TAUNT_PATROL;
pub use crate::bg_public_h::EV_TAUNT_YES;
pub use crate::bg_public_h::EV_USE_ITEM0;
pub use crate::bg_public_h::EV_USE_ITEM1;
pub use crate::bg_public_h::EV_USE_ITEM10;
pub use crate::bg_public_h::EV_USE_ITEM11;
pub use crate::bg_public_h::EV_USE_ITEM12;
pub use crate::bg_public_h::EV_USE_ITEM13;
pub use crate::bg_public_h::EV_USE_ITEM14;
pub use crate::bg_public_h::EV_USE_ITEM15;
pub use crate::bg_public_h::EV_USE_ITEM2;
pub use crate::bg_public_h::EV_USE_ITEM3;
pub use crate::bg_public_h::EV_USE_ITEM4;
pub use crate::bg_public_h::EV_USE_ITEM5;
pub use crate::bg_public_h::EV_USE_ITEM6;
pub use crate::bg_public_h::EV_USE_ITEM7;
pub use crate::bg_public_h::EV_USE_ITEM8;
pub use crate::bg_public_h::EV_USE_ITEM9;
pub use crate::bg_public_h::EV_WATER_CLEAR;
pub use crate::bg_public_h::EV_WATER_LEAVE;
pub use crate::bg_public_h::EV_WATER_TOUCH;
pub use crate::bg_public_h::EV_WATER_UNDER;
pub use crate::bg_public_h::FLAG_RUN;
pub use crate::bg_public_h::FLAG_STAND;
pub use crate::bg_public_h::FLAG_STAND2RUN;
pub use crate::bg_public_h::GT_1FCTF;
pub use crate::bg_public_h::GT_CTF;
pub use crate::bg_public_h::GT_FFA;
pub use crate::bg_public_h::GT_HARVESTER;
pub use crate::bg_public_h::GT_MAX_GAME_TYPE;
pub use crate::bg_public_h::GT_OBELISK;
pub use crate::bg_public_h::GT_SINGLE_PLAYER;
pub use crate::bg_public_h::GT_TEAM;
pub use crate::bg_public_h::GT_TOURNAMENT;
pub use crate::bg_public_h::IT_AMMO;
pub use crate::bg_public_h::IT_ARMOR;
pub use crate::bg_public_h::IT_BAD;
pub use crate::bg_public_h::IT_HEALTH;
pub use crate::bg_public_h::IT_HOLDABLE;
pub use crate::bg_public_h::IT_PERSISTANT_POWERUP;
pub use crate::bg_public_h::IT_POWERUP;
pub use crate::bg_public_h::IT_TEAM;
pub use crate::bg_public_h::IT_WEAPON;
pub use crate::bg_public_h::LEGS_BACK;
pub use crate::bg_public_h::LEGS_BACKCR;
pub use crate::bg_public_h::LEGS_BACKWALK;
pub use crate::bg_public_h::LEGS_IDLE;
pub use crate::bg_public_h::LEGS_IDLECR;
pub use crate::bg_public_h::LEGS_JUMP;
pub use crate::bg_public_h::LEGS_JUMPB;
pub use crate::bg_public_h::LEGS_LAND;
pub use crate::bg_public_h::LEGS_LANDB;
pub use crate::bg_public_h::LEGS_RUN;
pub use crate::bg_public_h::LEGS_SWIM;
pub use crate::bg_public_h::LEGS_TURN;
pub use crate::bg_public_h::LEGS_WALK;
pub use crate::bg_public_h::LEGS_WALKCR;
pub use crate::bg_public_h::MAX_ANIMATIONS;
pub use crate::bg_public_h::MAX_TOTALANIMATIONS;
pub use crate::bg_public_h::PERS_ASSIST_COUNT;
pub use crate::bg_public_h::PERS_ATTACKEE_ARMOR;
pub use crate::bg_public_h::PERS_ATTACKER;
pub use crate::bg_public_h::PERS_CAPTURES;
pub use crate::bg_public_h::PERS_DEFEND_COUNT;
pub use crate::bg_public_h::PERS_EXCELLENT_COUNT;
pub use crate::bg_public_h::PERS_GAUNTLET_FRAG_COUNT;
pub use crate::bg_public_h::PERS_HITS;
pub use crate::bg_public_h::PERS_IMPRESSIVE_COUNT;
pub use crate::bg_public_h::PERS_KILLED;
pub use crate::bg_public_h::PERS_PLAYEREVENTS;
pub use crate::bg_public_h::PERS_RANK;
pub use crate::bg_public_h::PERS_SCORE;
pub use crate::bg_public_h::PERS_SPAWN_COUNT;
pub use crate::bg_public_h::PERS_TEAM;
pub use crate::bg_public_h::STAT_ARMOR;
pub use crate::bg_public_h::STAT_CLIENTS_READY;
pub use crate::bg_public_h::STAT_DEAD_YAW;
pub use crate::bg_public_h::STAT_HEALTH;
pub use crate::bg_public_h::STAT_HOLDABLE_ITEM;
pub use crate::bg_public_h::STAT_MAX_HEALTH;
pub use crate::bg_public_h::STAT_WEAPONS;
pub use crate::bg_public_h::TEAM_BLUE;
pub use crate::bg_public_h::TEAM_FREE;
pub use crate::bg_public_h::TEAM_NUM_TEAMS;
pub use crate::bg_public_h::TEAM_RED;
pub use crate::bg_public_h::TEAM_SPECTATOR;
pub use crate::bg_public_h::TORSO_AFFIRMATIVE;
pub use crate::bg_public_h::TORSO_ATTACK;
pub use crate::bg_public_h::TORSO_ATTACK2;
pub use crate::bg_public_h::TORSO_DROP;
pub use crate::bg_public_h::TORSO_FOLLOWME;
pub use crate::bg_public_h::TORSO_GESTURE;
pub use crate::bg_public_h::TORSO_GETFLAG;
pub use crate::bg_public_h::TORSO_GUARDBASE;
pub use crate::bg_public_h::TORSO_NEGATIVE;
pub use crate::bg_public_h::TORSO_PATROL;
pub use crate::bg_public_h::TORSO_RAISE;
pub use crate::bg_public_h::TORSO_STAND;
pub use crate::bg_public_h::TORSO_STAND2;
pub use crate::bg_public_h::WEAPON_DROPPING;
pub use crate::bg_public_h::WEAPON_FIRING;
pub use crate::bg_public_h::WEAPON_RAISING;
pub use crate::bg_public_h::WEAPON_READY;
pub use crate::bg_public_h::WP_BFG;
pub use crate::bg_public_h::WP_GAUNTLET;
pub use crate::bg_public_h::WP_GRAPPLING_HOOK;
pub use crate::bg_public_h::WP_GRENADE_LAUNCHER;
pub use crate::bg_public_h::WP_LIGHTNING;
pub use crate::bg_public_h::WP_MACHINEGUN;
pub use crate::bg_public_h::WP_NONE;
pub use crate::bg_public_h::WP_NUM_WEAPONS;
pub use crate::bg_public_h::WP_PLASMAGUN;
pub use crate::bg_public_h::WP_RAILGUN;
pub use crate::bg_public_h::WP_ROCKET_LAUNCHER;
pub use crate::bg_public_h::WP_SHOTGUN;
pub use crate::g_local_h::clientConnected_t;
pub use crate::g_local_h::clientPersistant_t;
pub use crate::g_local_h::clientSession_t;
pub use crate::g_local_h::gclient_s;
pub use crate::g_local_h::gclient_t;
pub use crate::g_local_h::gentity_s;
pub use crate::g_local_h::gentity_t;
pub use crate::g_local_h::level_locals_t;
pub use crate::g_local_h::moverState_t;
pub use crate::g_local_h::playerTeamStateState_t;
pub use crate::g_local_h::playerTeamState_t;
pub use crate::g_local_h::spectatorState_t;
pub use crate::g_local_h::CON_CONNECTED;
pub use crate::g_local_h::CON_CONNECTING;
pub use crate::g_local_h::CON_DISCONNECTED;
pub use crate::g_local_h::MOVER_1TO2;
pub use crate::g_local_h::MOVER_2TO1;
pub use crate::g_local_h::MOVER_POS1;
pub use crate::g_local_h::MOVER_POS2;
pub use crate::g_local_h::SPECTATOR_FOLLOW;
pub use crate::g_local_h::SPECTATOR_FREE;
pub use crate::g_local_h::SPECTATOR_NOT;
pub use crate::g_local_h::SPECTATOR_SCOREBOARD;
pub use crate::g_local_h::TEAM_ACTIVE;
pub use crate::g_local_h::TEAM_BEGIN;
pub use crate::g_public_h::entityShared_t;
pub use crate::src::game::ai_main::BotAIShutdownClient;
pub use crate::src::game::bg_misc::BG_PlayerStateToEntityState;
pub use crate::src::game::g_active::ClientEndFrame;
pub use crate::src::game::g_active::ClientThink;
pub use crate::src::game::g_bot::G_BotConnect;
pub use crate::src::game::g_bot::G_RemoveQueuedBotBegin;
pub use crate::src::game::g_client::q_shared_h::VectorLength;
pub use crate::src::game::g_cmds::BroadcastTeamChange;
pub use crate::src::game::g_cmds::StopFollowing;
pub use crate::src::game::g_combat::body_die;
pub use crate::src::game::g_combat::player_die;
pub use crate::src::game::g_combat::TossClientItems;
pub use crate::src::game::g_main::g_entities;
pub use crate::src::game::g_main::g_gametype;
pub use crate::src::game::g_main::g_inactivity;
pub use crate::src::game::g_main::g_password;
pub use crate::src::game::g_main::level;
pub use crate::src::game::g_main::CalculateRanks;
pub use crate::src::game::g_main::FindIntermissionPoint;
pub use crate::src::game::g_main::G_Error;
pub use crate::src::game::g_main::G_LogPrintf;
pub use crate::src::game::g_main::MoveClientToIntermission;
pub use crate::src::game::g_session::G_InitSessionData;
pub use crate::src::game::g_session::G_ReadSessionData;
pub use crate::src::game::g_spawn::G_SpawnInt;
pub use crate::src::game::g_svcmds::G_FilterPacket;
pub use crate::src::game::g_syscalls::trap_DropClient;
pub use crate::src::game::g_syscalls::trap_EntitiesInBox;
pub use crate::src::game::g_syscalls::trap_GetUsercmd;
pub use crate::src::game::g_syscalls::trap_GetUserinfo;
pub use crate::src::game::g_syscalls::trap_LinkEntity;
pub use crate::src::game::g_syscalls::trap_PointContents;
pub use crate::src::game::g_syscalls::trap_SendConsoleCommand;
pub use crate::src::game::g_syscalls::trap_SendServerCommand;
pub use crate::src::game::g_syscalls::trap_SetConfigstring;
pub use crate::src::game::g_syscalls::trap_UnlinkEntity;
pub use crate::src::game::g_utils::G_Find;
pub use crate::src::game::g_utils::G_InitGentity;
pub use crate::src::game::g_utils::G_KillBox;
pub use crate::src::game::g_utils::G_SetOrigin;
pub use crate::src::game::g_utils::G_Spawn;
pub use crate::src::game::g_utils::G_TempEntity;
pub use crate::src::game::g_utils::G_UseTargets;
pub use crate::src::qcommon::q_math::vec3_origin;
pub use crate::src::qcommon::q_shared::byte;
pub use crate::src::qcommon::q_shared::cplane_s;
pub use crate::src::qcommon::q_shared::cplane_t;
pub use crate::src::qcommon::q_shared::cvarHandle_t;
pub use crate::src::qcommon::q_shared::entityState_s;
pub use crate::src::qcommon::q_shared::entityState_t;
pub use crate::src::qcommon::q_shared::fileHandle_t;
pub use crate::src::qcommon::q_shared::playerState_s;
pub use crate::src::qcommon::q_shared::playerState_t;
pub use crate::src::qcommon::q_shared::qboolean;
pub use crate::src::qcommon::q_shared::qfalse;
pub use crate::src::qcommon::q_shared::qtrue;
pub use crate::src::qcommon::q_shared::trType_t;
pub use crate::src::qcommon::q_shared::trace_t;
pub use crate::src::qcommon::q_shared::trajectory_t;
pub use crate::src::qcommon::q_shared::usercmd_s;
pub use crate::src::qcommon::q_shared::usercmd_t;
pub use crate::src::qcommon::q_shared::va;
pub use crate::src::qcommon::q_shared::vec3_t;
pub use crate::src::qcommon::q_shared::vec_t;
pub use crate::src::qcommon::q_shared::vmCvar_t;
pub use crate::src::qcommon::q_shared::Info_Validate;
pub use crate::src::qcommon::q_shared::Info_ValueForKey;
pub use crate::src::qcommon::q_shared::Q_IsColorString;
pub use crate::src::qcommon::q_shared::Q_stricmp;
pub use crate::src::qcommon::q_shared::Q_strncpyz;
pub use crate::src::qcommon::q_shared::EXEC_APPEND;
pub use crate::src::qcommon::q_shared::EXEC_INSERT;
pub use crate::src::qcommon::q_shared::EXEC_NOW;
pub use crate::src::qcommon::q_shared::TR_GRAVITY;
pub use crate::src::qcommon::q_shared::TR_INTERPOLATE;
pub use crate::src::qcommon::q_shared::TR_LINEAR;
pub use crate::src::qcommon::q_shared::TR_LINEAR_STOP;
pub use crate::src::qcommon::q_shared::TR_SINE;
pub use crate::src::qcommon::q_shared::TR_STATIONARY;
use crate::stdlib::sqrt;

pub use crate::src::game::g_client::stdlib_h::atoi;
use crate::src::game::g_team::SelectCTFSpawnPoint;
use crate::stdlib::memset;
pub use ::libc::rand;
use ::libc::strcmp;
use ::libc::strcpy;
pub use ::libc::strtol;
/*
===========================================================================
Copyright (C) 1999-2005 Id Software, Inc.

This file is part of Quake III Arena source code.

Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Quake III Arena source code; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/
//
// g_client.c -- client functions that don't happen every frame

static mut playerMins: crate::src::qcommon::q_shared::vec3_t = [
    -(15 as libc::c_int) as crate::src::qcommon::q_shared::vec_t,
    -(15 as libc::c_int) as crate::src::qcommon::q_shared::vec_t,
    -(24 as libc::c_int) as crate::src::qcommon::q_shared::vec_t,
];

static mut playerMaxs: crate::src::qcommon::q_shared::vec3_t = [
    15 as libc::c_int as crate::src::qcommon::q_shared::vec_t,
    15 as libc::c_int as crate::src::qcommon::q_shared::vec_t,
    32 as libc::c_int as crate::src::qcommon::q_shared::vec_t,
];
/*QUAKED info_player_deathmatch (1 0 1) (-16 -16 -24) (16 16 32) initial
potential spawning position for deathmatch games.
The first time a player enters the game, they will be at an 'initial' spot.
Targets will be fired when someone spawns in on them.
"nobots" will prevent bots from using this spot.
"nohumans" will prevent non-bots from using this spot.
*/
#[no_mangle]

pub unsafe extern "C" fn SP_info_player_deathmatch(mut ent: *mut crate::g_local_h::gentity_t) {
    let mut i: libc::c_int = 0;
    crate::src::game::g_spawn::G_SpawnInt(
        b"nobots\x00" as *const u8 as *const libc::c_char,
        b"0\x00" as *const u8 as *const libc::c_char,
        &mut i,
    );
    if i != 0 {
        (*ent).flags |= 0x2000 as libc::c_int
    }
    crate::src::game::g_spawn::G_SpawnInt(
        b"nohumans\x00" as *const u8 as *const libc::c_char,
        b"0\x00" as *const u8 as *const libc::c_char,
        &mut i,
    );
    if i != 0 {
        (*ent).flags |= 0x4000 as libc::c_int
    };
}
/*QUAKED info_player_start (1 0 0) (-16 -16 -24) (16 16 32)
equivalent to info_player_deathmatch
*/
#[no_mangle]

pub unsafe extern "C" fn SP_info_player_start(mut ent: *mut crate::g_local_h::gentity_t) {
    (*ent).classname =
        b"info_player_deathmatch\x00" as *const u8 as *const libc::c_char as *mut libc::c_char;
    SP_info_player_deathmatch(ent);
}
/*QUAKED info_player_intermission (1 0 1) (-16 -16 -24) (16 16 32)
The intermission will be viewed from this point.  Target an info_notnull for the view direction.
*/
#[no_mangle]

pub unsafe extern "C" fn SP_info_player_intermission(mut ent: *mut crate::g_local_h::gentity_t) {}
/*
=======================================================================

  SelectSpawnPoint

=======================================================================
*/
/*
================
SpotWouldTelefrag

================
*/
#[no_mangle]

pub unsafe extern "C" fn SpotWouldTelefrag(
    mut spot: *mut crate::g_local_h::gentity_t,
) -> crate::src::qcommon::q_shared::qboolean {
    let mut i: libc::c_int = 0;
    let mut num: libc::c_int = 0;
    let mut touch: [libc::c_int; 1024] = [0; 1024];
    let mut hit: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut mins: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    let mut maxs: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    mins[0 as libc::c_int as usize] =
        (*spot).s.origin[0 as libc::c_int as usize] + playerMins[0 as libc::c_int as usize];
    mins[1 as libc::c_int as usize] =
        (*spot).s.origin[1 as libc::c_int as usize] + playerMins[1 as libc::c_int as usize];
    mins[2 as libc::c_int as usize] =
        (*spot).s.origin[2 as libc::c_int as usize] + playerMins[2 as libc::c_int as usize];
    maxs[0 as libc::c_int as usize] =
        (*spot).s.origin[0 as libc::c_int as usize] + playerMaxs[0 as libc::c_int as usize];
    maxs[1 as libc::c_int as usize] =
        (*spot).s.origin[1 as libc::c_int as usize] + playerMaxs[1 as libc::c_int as usize];
    maxs[2 as libc::c_int as usize] =
        (*spot).s.origin[2 as libc::c_int as usize] + playerMaxs[2 as libc::c_int as usize];
    num = crate::src::game::g_syscalls::trap_EntitiesInBox(
        mins.as_mut_ptr() as *const crate::src::qcommon::q_shared::vec_t,
        maxs.as_mut_ptr() as *const crate::src::qcommon::q_shared::vec_t,
        touch.as_mut_ptr(),
        (1 as libc::c_int) << 10 as libc::c_int,
    );
    i = 0 as libc::c_int;
    while i < num {
        hit = &mut *crate::src::game::g_main::g_entities
            .as_mut_ptr()
            .offset(*touch.as_mut_ptr().offset(i as isize) as isize)
            as *mut crate::g_local_h::gentity_t;
        //if ( hit->client && hit->client->ps.stats[STAT_HEALTH] > 0 ) {
        if !(*hit).client.is_null() {
            return crate::src::qcommon::q_shared::qtrue;
        }
        i += 1
    }
    return crate::src::qcommon::q_shared::qfalse;
}
/*
================
SelectNearestDeathmatchSpawnPoint

Find the spot that we DON'T want to use
================
*/
#[no_mangle]

pub unsafe extern "C" fn SelectNearestDeathmatchSpawnPoint(
    mut from: *mut crate::src::qcommon::q_shared::vec_t,
) -> *mut crate::g_local_h::gentity_t {
    let mut spot: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut delta: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    let mut dist: libc::c_float = 0.;
    let mut nearestDist: libc::c_float = 0.;
    let mut nearestSpot: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    nearestDist = 999999 as libc::c_int as libc::c_float;
    nearestSpot = 0 as *mut crate::g_local_h::gentity_t;
    spot = 0 as *mut crate::g_local_h::gentity_t;
    loop {
        spot = crate::src::game::g_utils::G_Find(
            spot as *mut crate::g_local_h::gentity_s,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut libc::c_char
                as crate::stddef_h::size_t as libc::c_int,
            b"info_player_deathmatch\x00" as *const u8 as *const libc::c_char,
        ) as *mut crate::g_local_h::gentity_s;
        if spot.is_null() {
            break;
        }
        delta[0 as libc::c_int as usize] =
            (*spot).s.origin[0 as libc::c_int as usize] - *from.offset(0 as libc::c_int as isize);
        delta[1 as libc::c_int as usize] =
            (*spot).s.origin[1 as libc::c_int as usize] - *from.offset(1 as libc::c_int as isize);
        delta[2 as libc::c_int as usize] =
            (*spot).s.origin[2 as libc::c_int as usize] - *from.offset(2 as libc::c_int as isize);
        dist = VectorLength(delta.as_mut_ptr() as *const crate::src::qcommon::q_shared::vec_t);
        if dist < nearestDist {
            nearestDist = dist;
            nearestSpot = spot
        }
    }
    return nearestSpot;
}
#[no_mangle]

pub unsafe extern "C" fn SelectRandomDeathmatchSpawnPoint(
    mut isbot: crate::src::qcommon::q_shared::qboolean,
) -> *mut crate::g_local_h::gentity_t {
    let mut spot: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut count: libc::c_int = 0;
    let mut selection: libc::c_int = 0;
    let mut spots: [*mut crate::g_local_h::gentity_t; 128] =
        [0 as *mut crate::g_local_h::gentity_t; 128];
    count = 0 as libc::c_int;
    spot = 0 as *mut crate::g_local_h::gentity_t;
    loop
    // spot is not for this human/bot player
    {
        spot = crate::src::game::g_utils::G_Find(
            spot as *mut crate::g_local_h::gentity_s,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut libc::c_char
                as crate::stddef_h::size_t as libc::c_int,
            b"info_player_deathmatch\x00" as *const u8 as *const libc::c_char,
        ) as *mut crate::g_local_h::gentity_s;
        if !(!spot.is_null() && count < 128 as libc::c_int) {
            break;
        }
        if SpotWouldTelefrag(spot) as u64 != 0 {
            continue;
        }
        if (*spot).flags & 0x2000 as libc::c_int != 0 && isbot as libc::c_uint != 0
            || (*spot).flags & 0x4000 as libc::c_int != 0 && isbot as u64 == 0
        {
            continue;
        }
        spots[count as usize] = spot;
        count += 1
    }
    if count == 0 {
        // no spots that won't telefrag
        return crate::src::game::g_utils::G_Find(
            0 as *mut crate::g_local_h::gentity_t as *mut crate::g_local_h::gentity_s,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut libc::c_char
                as crate::stddef_h::size_t as libc::c_int,
            b"info_player_deathmatch\x00" as *const u8 as *const libc::c_char,
        ) as *mut crate::g_local_h::gentity_s;
    }
    selection = ::libc::rand() % count;
    return spots[selection as usize];
}
/*
===========
SelectRandomFurthestSpawnPoint

Chooses a player start, deathmatch start, etc
============
*/
#[no_mangle]

pub unsafe extern "C" fn SelectRandomFurthestSpawnPoint(
    mut avoidPoint: *mut crate::src::qcommon::q_shared::vec_t,
    mut origin: *mut crate::src::qcommon::q_shared::vec_t,
    mut angles: *mut crate::src::qcommon::q_shared::vec_t,
    mut isbot: crate::src::qcommon::q_shared::qboolean,
) -> *mut crate::g_local_h::gentity_t {
    let mut spot: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut delta: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    let mut dist: libc::c_float = 0.;
    let mut list_dist: [libc::c_float; 128] = [0.; 128];
    let mut list_spot: [*mut crate::g_local_h::gentity_t; 128] =
        [0 as *mut crate::g_local_h::gentity_t; 128];
    let mut numSpots: libc::c_int = 0;
    let mut rnd: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    numSpots = 0 as libc::c_int;
    spot = 0 as *mut crate::g_local_h::gentity_t;
    loop
    // spot is not for this human/bot player
    {
        spot = crate::src::game::g_utils::G_Find(
            spot as *mut crate::g_local_h::gentity_s,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut libc::c_char
                as crate::stddef_h::size_t as libc::c_int,
            b"info_player_deathmatch\x00" as *const u8 as *const libc::c_char,
        ) as *mut crate::g_local_h::gentity_s;
        if spot.is_null() {
            break;
        }
        if SpotWouldTelefrag(spot) as u64 != 0 {
            continue;
        }
        if (*spot).flags & 0x2000 as libc::c_int != 0 && isbot as libc::c_uint != 0
            || (*spot).flags & 0x4000 as libc::c_int != 0 && isbot as u64 == 0
        {
            continue;
        }
        delta[0 as libc::c_int as usize] = (*spot).s.origin[0 as libc::c_int as usize]
            - *avoidPoint.offset(0 as libc::c_int as isize);
        delta[1 as libc::c_int as usize] = (*spot).s.origin[1 as libc::c_int as usize]
            - *avoidPoint.offset(1 as libc::c_int as isize);
        delta[2 as libc::c_int as usize] = (*spot).s.origin[2 as libc::c_int as usize]
            - *avoidPoint.offset(2 as libc::c_int as isize);
        dist = VectorLength(delta.as_mut_ptr() as *const crate::src::qcommon::q_shared::vec_t);
        i = 0 as libc::c_int;
        while i < numSpots {
            if dist > list_dist[i as usize] {
                if numSpots >= 128 as libc::c_int {
                    numSpots = 128 as libc::c_int - 1 as libc::c_int
                }
                j = numSpots;
                while j > i {
                    list_dist[j as usize] = list_dist[(j - 1 as libc::c_int) as usize];
                    list_spot[j as usize] = list_spot[(j - 1 as libc::c_int) as usize];
                    j -= 1
                }
                list_dist[i as usize] = dist;
                list_spot[i as usize] = spot;
                numSpots += 1;
                break;
            } else {
                i += 1
            }
        }
        if i >= numSpots && numSpots < 128 as libc::c_int {
            list_dist[numSpots as usize] = dist;
            list_spot[numSpots as usize] = spot;
            numSpots += 1
        }
    }
    if numSpots == 0 {
        spot = crate::src::game::g_utils::G_Find(
            0 as *mut crate::g_local_h::gentity_t as *mut crate::g_local_h::gentity_s,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut libc::c_char
                as crate::stddef_h::size_t as libc::c_int,
            b"info_player_deathmatch\x00" as *const u8 as *const libc::c_char,
        ) as *mut crate::g_local_h::gentity_s;
        if spot.is_null() {
            crate::src::game::g_main::G_Error(
                b"Couldn\'t find a spawn point\x00" as *const u8 as *const libc::c_char,
            );
        }
        *origin.offset(0 as libc::c_int as isize) = (*spot).s.origin[0 as libc::c_int as usize];
        *origin.offset(1 as libc::c_int as isize) = (*spot).s.origin[1 as libc::c_int as usize];
        *origin.offset(2 as libc::c_int as isize) = (*spot).s.origin[2 as libc::c_int as usize];
        let ref mut fresh0 = *origin.offset(2 as libc::c_int as isize);
        *fresh0 += 9 as libc::c_int as libc::c_float;
        *angles.offset(0 as libc::c_int as isize) = (*spot).s.angles[0 as libc::c_int as usize];
        *angles.offset(1 as libc::c_int as isize) = (*spot).s.angles[1 as libc::c_int as usize];
        *angles.offset(2 as libc::c_int as isize) = (*spot).s.angles[2 as libc::c_int as usize];
        return spot;
    }
    // select a random spot from the spawn points furthest away
    rnd = ((::libc::rand() & 0x7fff as libc::c_int) as libc::c_float
        / 0x7fff as libc::c_int as libc::c_float
        * (numSpots / 2 as libc::c_int) as libc::c_float) as libc::c_int;
    *origin.offset(0 as libc::c_int as isize) =
        (*list_spot[rnd as usize]).s.origin[0 as libc::c_int as usize];
    *origin.offset(1 as libc::c_int as isize) =
        (*list_spot[rnd as usize]).s.origin[1 as libc::c_int as usize];
    *origin.offset(2 as libc::c_int as isize) =
        (*list_spot[rnd as usize]).s.origin[2 as libc::c_int as usize];
    let ref mut fresh1 = *origin.offset(2 as libc::c_int as isize);
    *fresh1 += 9 as libc::c_int as libc::c_float;
    *angles.offset(0 as libc::c_int as isize) =
        (*list_spot[rnd as usize]).s.angles[0 as libc::c_int as usize];
    *angles.offset(1 as libc::c_int as isize) =
        (*list_spot[rnd as usize]).s.angles[1 as libc::c_int as usize];
    *angles.offset(2 as libc::c_int as isize) =
        (*list_spot[rnd as usize]).s.angles[2 as libc::c_int as usize];
    return list_spot[rnd as usize];
}
/*
===========
SelectSpawnPoint

Chooses a player start, deathmatch start, etc
============
*/
#[no_mangle]

pub unsafe extern "C" fn SelectSpawnPoint(
    mut avoidPoint: *mut crate::src::qcommon::q_shared::vec_t,
    mut origin: *mut crate::src::qcommon::q_shared::vec_t,
    mut angles: *mut crate::src::qcommon::q_shared::vec_t,
    mut isbot: crate::src::qcommon::q_shared::qboolean,
) -> *mut crate::g_local_h::gentity_t {
    return SelectRandomFurthestSpawnPoint(avoidPoint, origin, angles, isbot);
    /*
    gentity_t	*spot;
    gentity_t	*nearestSpot;

    nearestSpot = SelectNearestDeathmatchSpawnPoint( avoidPoint );

    spot = SelectRandomDeathmatchSpawnPoint ( );
    if ( spot == nearestSpot ) {
        // roll again if it would be real close to point of death
        spot = SelectRandomDeathmatchSpawnPoint ( );
        if ( spot == nearestSpot ) {
            // last try
            spot = SelectRandomDeathmatchSpawnPoint ( );
        }
    }

    // find a single player start spot
    if (!spot) {
        G_Error( "Couldn't find a spawn point" );
    }

    VectorCopy (spot->s.origin, origin);
    origin[2] += 9;
    VectorCopy (spot->s.angles, angles);

    return spot;
    */
}
/*
===========
SelectInitialSpawnPoint

Try to find a spawn point marked 'initial', otherwise
use normal spawn selection.
============
*/
#[no_mangle]

pub unsafe extern "C" fn SelectInitialSpawnPoint(
    mut origin: *mut crate::src::qcommon::q_shared::vec_t,
    mut angles: *mut crate::src::qcommon::q_shared::vec_t,
    mut isbot: crate::src::qcommon::q_shared::qboolean,
) -> *mut crate::g_local_h::gentity_t {
    let mut spot: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    spot = 0 as *mut crate::g_local_h::gentity_t;
    loop {
        spot = crate::src::game::g_utils::G_Find(
            spot as *mut crate::g_local_h::gentity_s,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut libc::c_char
                as crate::stddef_h::size_t as libc::c_int,
            b"info_player_deathmatch\x00" as *const u8 as *const libc::c_char,
        ) as *mut crate::g_local_h::gentity_s;
        if spot.is_null() {
            break;
        }
        if (*spot).flags & 0x2000 as libc::c_int != 0 && isbot as libc::c_uint != 0
            || (*spot).flags & 0x4000 as libc::c_int != 0 && isbot as u64 == 0
        {
            continue;
        }
        if (*spot).spawnflags & 0x1 as libc::c_int != 0 {
            break;
        }
    }
    if spot.is_null() || SpotWouldTelefrag(spot) as libc::c_uint != 0 {
        return SelectSpawnPoint(
            crate::src::qcommon::q_math::vec3_origin.as_mut_ptr(),
            origin,
            angles,
            isbot,
        );
    }
    *origin.offset(0 as libc::c_int as isize) = (*spot).s.origin[0 as libc::c_int as usize];
    *origin.offset(1 as libc::c_int as isize) = (*spot).s.origin[1 as libc::c_int as usize];
    *origin.offset(2 as libc::c_int as isize) = (*spot).s.origin[2 as libc::c_int as usize];
    let ref mut fresh2 = *origin.offset(2 as libc::c_int as isize);
    *fresh2 += 9 as libc::c_int as libc::c_float;
    *angles.offset(0 as libc::c_int as isize) = (*spot).s.angles[0 as libc::c_int as usize];
    *angles.offset(1 as libc::c_int as isize) = (*spot).s.angles[1 as libc::c_int as usize];
    *angles.offset(2 as libc::c_int as isize) = (*spot).s.angles[2 as libc::c_int as usize];
    return spot;
}
/*
===========
SelectSpectatorSpawnPoint

============
*/
#[no_mangle]

pub unsafe extern "C" fn SelectSpectatorSpawnPoint(
    mut origin: *mut crate::src::qcommon::q_shared::vec_t,
    mut angles: *mut crate::src::qcommon::q_shared::vec_t,
) -> *mut crate::g_local_h::gentity_t {
    crate::src::game::g_main::FindIntermissionPoint();
    *origin.offset(0 as libc::c_int as isize) =
        crate::src::game::g_main::level.intermission_origin[0 as libc::c_int as usize];
    *origin.offset(1 as libc::c_int as isize) =
        crate::src::game::g_main::level.intermission_origin[1 as libc::c_int as usize];
    *origin.offset(2 as libc::c_int as isize) =
        crate::src::game::g_main::level.intermission_origin[2 as libc::c_int as usize];
    *angles.offset(0 as libc::c_int as isize) =
        crate::src::game::g_main::level.intermission_angle[0 as libc::c_int as usize];
    *angles.offset(1 as libc::c_int as isize) =
        crate::src::game::g_main::level.intermission_angle[1 as libc::c_int as usize];
    *angles.offset(2 as libc::c_int as isize) =
        crate::src::game::g_main::level.intermission_angle[2 as libc::c_int as usize];
    return 0 as *mut crate::g_local_h::gentity_t;
}
/*
=======================================================================

BODYQUE

=======================================================================
*/
/*
===============
InitBodyQue
===============
*/
#[no_mangle]

pub unsafe extern "C" fn InitBodyQue() {
    let mut i: libc::c_int = 0;
    let mut ent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    crate::src::game::g_main::level.bodyQueIndex = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < 8 as libc::c_int {
        ent = crate::src::game::g_utils::G_Spawn() as *mut crate::g_local_h::gentity_s;
        (*ent).classname = b"bodyque\x00" as *const u8 as *const libc::c_char as *mut libc::c_char;
        (*ent).neverFree = crate::src::qcommon::q_shared::qtrue;
        crate::src::game::g_main::level.bodyQue[i as usize] = ent;
        i += 1
    }
}
/*
=============
BodySink

After sitting around for five seconds, fall into the ground and disappear
=============
*/
#[no_mangle]

pub unsafe extern "C" fn BodySink(mut ent: *mut crate::g_local_h::gentity_t) {
    if crate::src::game::g_main::level.time - (*ent).timestamp > 6500 as libc::c_int {
        // the body ques are never actually freed, they are just unlinked
        crate::src::game::g_syscalls::trap_UnlinkEntity(ent as *mut crate::g_local_h::gentity_s);
        (*ent).physicsObject = crate::src::qcommon::q_shared::qfalse;
        return;
    }
    (*ent).nextthink = crate::src::game::g_main::level.time + 100 as libc::c_int;
    (*ent).s.pos.trBase[2 as libc::c_int as usize] -= 1 as libc::c_int as libc::c_float;
}
/*
=============
CopyToBodyQue

A player is respawning, so make an entity that looks
just like the existing corpse to leave behind.
=============
*/
#[no_mangle]

pub unsafe extern "C" fn CopyToBodyQue(mut ent: *mut crate::g_local_h::gentity_t) {
    let mut body: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut contents: libc::c_int = 0;
    crate::src::game::g_syscalls::trap_UnlinkEntity(ent as *mut crate::g_local_h::gentity_s);
    // if client is in a nodrop area, don't leave the body
    contents = crate::src::game::g_syscalls::trap_PointContents(
        (*ent).s.origin.as_mut_ptr() as *const crate::src::qcommon::q_shared::vec_t,
        -(1 as libc::c_int),
    );
    if contents as libc::c_uint & 0x80000000 as libc::c_uint != 0 {
        return;
    }
    // grab a body que and cycle to the next one
    body = crate::src::game::g_main::level.bodyQue
        [crate::src::game::g_main::level.bodyQueIndex as usize]; // clear EF_TALK, etc
    crate::src::game::g_main::level.bodyQueIndex =
        (crate::src::game::g_main::level.bodyQueIndex + 1 as libc::c_int) % 8 as libc::c_int; // clear powerups
    (*body).s = (*ent).s; // clear lava burning
    (*body).s.eFlags = 0x1 as libc::c_int; // don't bounce
    (*body).s.powerups = 0 as libc::c_int;
    (*body).s.loopSound = 0 as libc::c_int;
    (*body).s.number = body.wrapping_offset_from(crate::src::game::g_main::g_entities.as_mut_ptr())
        as libc::c_long as libc::c_int;
    (*body).timestamp = crate::src::game::g_main::level.time;
    (*body).physicsObject = crate::src::qcommon::q_shared::qtrue;
    (*body).physicsBounce = 0 as libc::c_int as libc::c_float;
    if (*body).s.groundEntityNum == ((1 as libc::c_int) << 10 as libc::c_int) - 1 as libc::c_int {
        (*body).s.pos.trType = crate::src::qcommon::q_shared::TR_GRAVITY;
        (*body).s.pos.trTime = crate::src::game::g_main::level.time;
        (*body).s.pos.trDelta[0 as libc::c_int as usize] =
            (*(*ent).client).ps.velocity[0 as libc::c_int as usize];
        (*body).s.pos.trDelta[1 as libc::c_int as usize] =
            (*(*ent).client).ps.velocity[1 as libc::c_int as usize];
        (*body).s.pos.trDelta[2 as libc::c_int as usize] =
            (*(*ent).client).ps.velocity[2 as libc::c_int as usize]
    } else {
        (*body).s.pos.trType = crate::src::qcommon::q_shared::TR_STATIONARY
    }
    (*body).s.event = 0 as libc::c_int;
    // change the animation to the last-frame only, so the sequence
    // doesn't repeat anew for the body
    match (*body).s.legsAnim & !(128 as libc::c_int) {
        0 | 1 => {
            (*body).s.legsAnim = crate::bg_public_h::BOTH_DEAD1 as libc::c_int;
            (*body).s.torsoAnim = (*body).s.legsAnim
        }
        2 | 3 => {
            (*body).s.legsAnim = crate::bg_public_h::BOTH_DEAD2 as libc::c_int;
            (*body).s.torsoAnim = (*body).s.legsAnim
        }
        4 | 5 | _ => {
            (*body).s.legsAnim = crate::bg_public_h::BOTH_DEAD3 as libc::c_int;
            (*body).s.torsoAnim = (*body).s.legsAnim
        }
    }
    (*body).r.svFlags = (*ent).r.svFlags;
    (*body).r.mins[0 as libc::c_int as usize] = (*ent).r.mins[0 as libc::c_int as usize];
    (*body).r.mins[1 as libc::c_int as usize] = (*ent).r.mins[1 as libc::c_int as usize];
    (*body).r.mins[2 as libc::c_int as usize] = (*ent).r.mins[2 as libc::c_int as usize];
    (*body).r.maxs[0 as libc::c_int as usize] = (*ent).r.maxs[0 as libc::c_int as usize];
    (*body).r.maxs[1 as libc::c_int as usize] = (*ent).r.maxs[1 as libc::c_int as usize];
    (*body).r.maxs[2 as libc::c_int as usize] = (*ent).r.maxs[2 as libc::c_int as usize];
    (*body).r.absmin[0 as libc::c_int as usize] = (*ent).r.absmin[0 as libc::c_int as usize];
    (*body).r.absmin[1 as libc::c_int as usize] = (*ent).r.absmin[1 as libc::c_int as usize];
    (*body).r.absmin[2 as libc::c_int as usize] = (*ent).r.absmin[2 as libc::c_int as usize];
    (*body).r.absmax[0 as libc::c_int as usize] = (*ent).r.absmax[0 as libc::c_int as usize];
    (*body).r.absmax[1 as libc::c_int as usize] = (*ent).r.absmax[1 as libc::c_int as usize];
    (*body).r.absmax[2 as libc::c_int as usize] = (*ent).r.absmax[2 as libc::c_int as usize];
    (*body).clipmask = 1 as libc::c_int | 0x10000 as libc::c_int;
    (*body).r.contents = 0x4000000 as libc::c_int;
    (*body).r.ownerNum = (*ent).s.number;
    (*body).nextthink = crate::src::game::g_main::level.time + 5000 as libc::c_int;
    (*body).think =
        Some(BodySink as unsafe extern "C" fn(_: *mut crate::g_local_h::gentity_t) -> ());
    (*body).die = Some(
        crate::src::game::g_combat::body_die
            as unsafe extern "C" fn(
                _: *mut crate::g_local_h::gentity_t,
                _: *mut crate::g_local_h::gentity_t,
                _: *mut crate::g_local_h::gentity_t,
                _: libc::c_int,
                _: libc::c_int,
            ) -> (),
    );
    // don't take more damage if already gibbed
    if (*ent).health <= -(40 as libc::c_int) {
        (*body).takedamage = crate::src::qcommon::q_shared::qfalse
    } else {
        (*body).takedamage = crate::src::qcommon::q_shared::qtrue
    }
    (*body).r.currentOrigin[0 as libc::c_int as usize] =
        (*body).s.pos.trBase[0 as libc::c_int as usize];
    (*body).r.currentOrigin[1 as libc::c_int as usize] =
        (*body).s.pos.trBase[1 as libc::c_int as usize];
    (*body).r.currentOrigin[2 as libc::c_int as usize] =
        (*body).s.pos.trBase[2 as libc::c_int as usize];
    crate::src::game::g_syscalls::trap_LinkEntity(body as *mut crate::g_local_h::gentity_s);
}
//======================================================================
/*
==================
SetClientViewAngle

==================
*/
#[no_mangle]

pub unsafe extern "C" fn SetClientViewAngle(
    mut ent: *mut crate::g_local_h::gentity_t,
    mut angle: *mut crate::src::qcommon::q_shared::vec_t,
) {
    let mut i: libc::c_int = 0;
    // set the delta angle
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        let mut cmdAngle: libc::c_int = 0;
        cmdAngle = (*angle.offset(i as isize) * 65536 as libc::c_int as libc::c_float
            / 360 as libc::c_int as libc::c_float) as libc::c_int
            & 65535 as libc::c_int;
        (*(*ent).client).ps.delta_angles[i as usize] =
            cmdAngle - (*(*ent).client).pers.cmd.angles[i as usize];
        i += 1
    }
    (*ent).s.angles[0 as libc::c_int as usize] = *angle.offset(0 as libc::c_int as isize);
    (*ent).s.angles[1 as libc::c_int as usize] = *angle.offset(1 as libc::c_int as isize);
    (*ent).s.angles[2 as libc::c_int as usize] = *angle.offset(2 as libc::c_int as isize);
    (*(*ent).client).ps.viewangles[0 as libc::c_int as usize] =
        (*ent).s.angles[0 as libc::c_int as usize];
    (*(*ent).client).ps.viewangles[1 as libc::c_int as usize] =
        (*ent).s.angles[1 as libc::c_int as usize];
    (*(*ent).client).ps.viewangles[2 as libc::c_int as usize] =
        (*ent).s.angles[2 as libc::c_int as usize];
}
/*
================
ClientRespawn
================
*/
#[no_mangle]

pub unsafe extern "C" fn ClientRespawn(mut ent: *mut crate::g_local_h::gentity_t) {
    CopyToBodyQue(ent);
    ClientSpawn(ent);
}
/*
================
TeamCount

Returns number of players on a team
================
*/
#[no_mangle]

pub unsafe extern "C" fn TeamCount(
    mut ignoreClientNum: libc::c_int,
    mut team: crate::bg_public_h::team_t,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut count: libc::c_int = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < crate::src::game::g_main::level.maxclients {
        if !(i == ignoreClientNum) {
            if !((*crate::src::game::g_main::level.clients.offset(i as isize))
                .pers
                .connected as libc::c_uint
                == crate::g_local_h::CON_DISCONNECTED as libc::c_int as libc::c_uint)
            {
                if (*crate::src::game::g_main::level.clients.offset(i as isize))
                    .sess
                    .sessionTeam as libc::c_uint
                    == team as libc::c_uint
                {
                    count += 1
                }
            }
        }
        i += 1
    }
    return count;
}
/*
================
TeamLeader

Returns the client number of the team leader
================
*/
#[no_mangle]

pub unsafe extern "C" fn TeamLeader(mut team: libc::c_int) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < crate::src::game::g_main::level.maxclients {
        if !((*crate::src::game::g_main::level.clients.offset(i as isize))
            .pers
            .connected as libc::c_uint
            == crate::g_local_h::CON_DISCONNECTED as libc::c_int as libc::c_uint)
        {
            if (*crate::src::game::g_main::level.clients.offset(i as isize))
                .sess
                .sessionTeam as libc::c_uint
                == team as libc::c_uint
            {
                if (*crate::src::game::g_main::level.clients.offset(i as isize))
                    .sess
                    .teamLeader as u64
                    != 0
                {
                    return i;
                }
            }
        }
        i += 1
    }
    return -(1 as libc::c_int);
}
/*
================
PickTeam

================
*/
#[no_mangle]

pub unsafe extern "C" fn PickTeam(mut ignoreClientNum: libc::c_int) -> crate::bg_public_h::team_t {
    let mut counts: [libc::c_int; 4] = [0; 4];
    counts[crate::bg_public_h::TEAM_BLUE as libc::c_int as usize] =
        TeamCount(ignoreClientNum, crate::bg_public_h::TEAM_BLUE);
    counts[crate::bg_public_h::TEAM_RED as libc::c_int as usize] =
        TeamCount(ignoreClientNum, crate::bg_public_h::TEAM_RED);
    if counts[crate::bg_public_h::TEAM_BLUE as libc::c_int as usize]
        > counts[crate::bg_public_h::TEAM_RED as libc::c_int as usize]
    {
        return crate::bg_public_h::TEAM_RED;
    }
    if counts[crate::bg_public_h::TEAM_RED as libc::c_int as usize]
        > counts[crate::bg_public_h::TEAM_BLUE as libc::c_int as usize]
    {
        return crate::bg_public_h::TEAM_BLUE;
    }
    // equal team count, so join the team with the lowest score
    if crate::src::game::g_main::level.teamScores
        [crate::bg_public_h::TEAM_BLUE as libc::c_int as usize]
        > crate::src::game::g_main::level.teamScores
            [crate::bg_public_h::TEAM_RED as libc::c_int as usize]
    {
        return crate::bg_public_h::TEAM_RED;
    }
    return crate::bg_public_h::TEAM_BLUE;
}
/*
===========
ForceClientSkin

Forces a client's skin (for teamplay)
===========
*/
/*
static void ForceClientSkin( gclient_t *client, char *model, const char *skin ) {
    char *p;

    if ((p = strrchr(model, '/')) != 0) {
        *p = 0;
    }

    Q_strcat(model, MAX_QPATH, "/");
    Q_strcat(model, MAX_QPATH, skin);
}
*/
/*
===========
ClientCleanName
============
*/

unsafe extern "C" fn ClientCleanName(
    mut in_0: *const libc::c_char,
    mut out: *mut libc::c_char,
    mut outSize: libc::c_int,
) {
    let mut outpos: libc::c_int = 0 as libc::c_int;
    let mut colorlessLen: libc::c_int = 0 as libc::c_int;
    let mut spaces: libc::c_int = 0 as libc::c_int;
    // discard leading spaces
    while *in_0 as libc::c_int == ' ' as i32 {
        in_0 = in_0.offset(1)
    }
    let mut current_block_12: u64;
    while *in_0 as libc::c_int != 0 && outpos < outSize - 1 as libc::c_int {
        *out.offset(outpos as isize) = *in_0;
        if *in_0 as libc::c_int == ' ' as i32 {
            // don't allow too many consecutive spaces
            if spaces > 2 as libc::c_int {
                current_block_12 = 4644295000439058019;
            } else {
                spaces += 1;
                current_block_12 = 26972500619410423;
            }
        } else if outpos > 0 as libc::c_int
            && *out.offset((outpos - 1 as libc::c_int) as isize) as libc::c_int == '^' as i32
        {
            if crate::src::qcommon::q_shared::Q_IsColorString(
                &mut *out.offset((outpos - 1 as libc::c_int) as isize),
            ) as u64
                != 0
            {
                colorlessLen -= 1;
                if *in_0 as libc::c_int - '0' as i32 & 0x7 as libc::c_int == 0 as libc::c_int {
                    // Disallow color black in names to prevent players
                    // from getting advantage playing in front of black backgrounds
                    outpos -= 1;
                    current_block_12 = 4644295000439058019;
                } else {
                    current_block_12 = 26972500619410423;
                }
            } else {
                spaces = 0 as libc::c_int;
                colorlessLen += 1;
                current_block_12 = 26972500619410423;
            }
        } else {
            spaces = 0 as libc::c_int;
            colorlessLen += 1;
            current_block_12 = 26972500619410423;
        }
        match current_block_12 {
            26972500619410423 => outpos += 1,
            _ => {}
        }
        in_0 = in_0.offset(1)
    }
    *out.offset(outpos as isize) = '\u{0}' as i32 as libc::c_char;
    // don't allow empty names
    if *out as libc::c_int == '\u{0}' as i32 || colorlessLen == 0 as libc::c_int {
        crate::src::qcommon::q_shared::Q_strncpyz(
            out,
            b"UnnamedPlayer\x00" as *const u8 as *const libc::c_char,
            outSize,
        );
    };
}
/*
===========
ClientUserInfoChanged

Called from ClientConnect when the player first connects and
directly by the server system when the player updates a userinfo variable.

The game can override any of the settings and call trap_SetUserinfo
if desired.
============
*/
#[no_mangle]

pub unsafe extern "C" fn ClientUserinfoChanged(mut clientNum: libc::c_int) {
    let mut ent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut teamTask: libc::c_int = 0;
    let mut teamLeader: libc::c_int = 0;
    let mut health: libc::c_int = 0;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut model: [libc::c_char; 64] = [0; 64];
    let mut headModel: [libc::c_char; 64] = [0; 64];
    let mut oldname: [libc::c_char; 1024] = [0; 1024];
    let mut client: *mut crate::g_local_h::gclient_t = 0 as *mut crate::g_local_h::gclient_t;
    let mut c1: [libc::c_char; 1024] = [0; 1024];
    let mut c2: [libc::c_char; 1024] = [0; 1024];
    let mut redTeam: [libc::c_char; 1024] = [0; 1024];
    let mut blueTeam: [libc::c_char; 1024] = [0; 1024];
    let mut userinfo: [libc::c_char; 1024] = [0; 1024];
    ent = crate::src::game::g_main::g_entities
        .as_mut_ptr()
        .offset(clientNum as isize);
    client = (*ent).client;
    crate::src::game::g_syscalls::trap_GetUserinfo(
        clientNum,
        userinfo.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong as libc::c_int,
    );
    // check for malformed or illegal info strings
    if crate::src::qcommon::q_shared::Info_Validate(userinfo.as_mut_ptr()) as u64 == 0 {
        ::libc::strcpy(
            userinfo.as_mut_ptr(),
            b"\\name\\badinfo\x00" as *const u8 as *const libc::c_char,
        );
        // don't keep those clients and userinfo
        crate::src::game::g_syscalls::trap_DropClient(
            clientNum,
            b"Invalid userinfo\x00" as *const u8 as *const libc::c_char,
        );
    }
    // check the item prediction
    s = crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"cg_predictItems\x00" as *const u8 as *const libc::c_char,
    );
    if atoi(s) == 0 {
        (*client).pers.predictItemPickup = crate::src::qcommon::q_shared::qfalse
    } else {
        (*client).pers.predictItemPickup = crate::src::qcommon::q_shared::qtrue
    }
    // set name
    crate::src::qcommon::q_shared::Q_strncpyz(
        oldname.as_mut_ptr(),
        (*client).pers.netname.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong as libc::c_int,
    );
    s = crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"name\x00" as *const u8 as *const libc::c_char,
    );
    ClientCleanName(
        s,
        (*client).pers.netname.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 36]>() as libc::c_ulong as libc::c_int,
    );
    if (*client).sess.sessionTeam as libc::c_uint
        == crate::bg_public_h::TEAM_SPECTATOR as libc::c_int as libc::c_uint
    {
        if (*client).sess.spectatorState as libc::c_uint
            == crate::g_local_h::SPECTATOR_SCOREBOARD as libc::c_int as libc::c_uint
        {
            crate::src::qcommon::q_shared::Q_strncpyz(
                (*client).pers.netname.as_mut_ptr(),
                b"scoreboard\x00" as *const u8 as *const libc::c_char,
                ::std::mem::size_of::<[libc::c_char; 36]>() as libc::c_ulong as libc::c_int,
            );
        }
    }
    if (*client).pers.connected as libc::c_uint
        == crate::g_local_h::CON_CONNECTED as libc::c_int as libc::c_uint
    {
        if ::libc::strcmp(oldname.as_mut_ptr(), (*client).pers.netname.as_mut_ptr()) != 0 {
            crate::src::game::g_syscalls::trap_SendServerCommand(
                -(1 as libc::c_int),
                crate::src::qcommon::q_shared::va(
                    b"print \"%s^7 renamed to %s\n\"\x00" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    oldname.as_mut_ptr(),
                    (*client).pers.netname.as_mut_ptr(),
                ),
            );
        }
    }
    // set max health
    health = atoi(crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"handicap\x00" as *const u8 as *const libc::c_char,
    ));
    (*client).pers.maxHealth = health;
    if (*client).pers.maxHealth < 1 as libc::c_int || (*client).pers.maxHealth > 100 as libc::c_int
    {
        (*client).pers.maxHealth = 100 as libc::c_int
    }
    (*client).ps.stats[crate::bg_public_h::STAT_MAX_HEALTH as libc::c_int as usize] =
        (*client).pers.maxHealth;
    // set model
    if crate::src::game::g_main::g_gametype.integer >= crate::bg_public_h::GT_TEAM as libc::c_int {
        crate::src::qcommon::q_shared::Q_strncpyz(
            model.as_mut_ptr(),
            crate::src::qcommon::q_shared::Info_ValueForKey(
                userinfo.as_mut_ptr(),
                b"team_model\x00" as *const u8 as *const libc::c_char,
            ),
            ::std::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
        );
        crate::src::qcommon::q_shared::Q_strncpyz(
            headModel.as_mut_ptr(),
            crate::src::qcommon::q_shared::Info_ValueForKey(
                userinfo.as_mut_ptr(),
                b"team_headmodel\x00" as *const u8 as *const libc::c_char,
            ),
            ::std::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
        );
    } else {
        crate::src::qcommon::q_shared::Q_strncpyz(
            model.as_mut_ptr(),
            crate::src::qcommon::q_shared::Info_ValueForKey(
                userinfo.as_mut_ptr(),
                b"model\x00" as *const u8 as *const libc::c_char,
            ),
            ::std::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
        );
        crate::src::qcommon::q_shared::Q_strncpyz(
            headModel.as_mut_ptr(),
            crate::src::qcommon::q_shared::Info_ValueForKey(
                userinfo.as_mut_ptr(),
                b"headmodel\x00" as *const u8 as *const libc::c_char,
            ),
            ::std::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
        );
    }
    /*	NOTE: all client side now

        // team
        switch( team ) {
        case TEAM_RED:
            ForceClientSkin(client, model, "red");
    //		ForceClientSkin(client, headModel, "red");
            break;
        case TEAM_BLUE:
            ForceClientSkin(client, model, "blue");
    //		ForceClientSkin(client, headModel, "blue");
            break;
        }
        // don't ever use a default skin in teamplay, it would just waste memory
        // however bots will always join a team but they spawn in as spectator
        if ( g_gametype.integer >= GT_TEAM && team == TEAM_SPECTATOR) {
            ForceClientSkin(client, model, "red");
    //		ForceClientSkin(client, headModel, "red");
        }
    */
    // teamInfo
    s = crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"teamoverlay\x00" as *const u8 as *const libc::c_char,
    );
    if *s == 0 || atoi(s) != 0 as libc::c_int {
        (*client).pers.teamInfo = crate::src::qcommon::q_shared::qtrue
    } else {
        (*client).pers.teamInfo = crate::src::qcommon::q_shared::qfalse
    }
    /*
    s = Info_ValueForKey( userinfo, "cg_pmove_fixed" );
    if ( !*s || atoi( s ) == 0 ) {
        client->pers.pmoveFixed = qfalse;
    }
    else {
        client->pers.pmoveFixed = qtrue;
    }
    */
    // team task (0 = none, 1 = offence, 2 = defence)
    teamTask = atoi(crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"teamtask\x00" as *const u8 as *const libc::c_char,
    ));
    // team Leader (1 = leader, 0 is normal player)
    teamLeader = (*client).sess.teamLeader as libc::c_int;
    // colors
    crate::src::qcommon::q_shared::Q_strncpyz(
        c1.as_mut_ptr(),
        crate::src::qcommon::q_shared::Info_ValueForKey(
            userinfo.as_mut_ptr(),
            b"color1\x00" as *const u8 as *const libc::c_char,
        ),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong as libc::c_int,
    );
    crate::src::qcommon::q_shared::Q_strncpyz(
        c2.as_mut_ptr(),
        crate::src::qcommon::q_shared::Info_ValueForKey(
            userinfo.as_mut_ptr(),
            b"color2\x00" as *const u8 as *const libc::c_char,
        ),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong as libc::c_int,
    );
    crate::src::qcommon::q_shared::Q_strncpyz(
        redTeam.as_mut_ptr(),
        crate::src::qcommon::q_shared::Info_ValueForKey(
            userinfo.as_mut_ptr(),
            b"g_redteam\x00" as *const u8 as *const libc::c_char,
        ),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong as libc::c_int,
    );
    crate::src::qcommon::q_shared::Q_strncpyz(
        blueTeam.as_mut_ptr(),
        crate::src::qcommon::q_shared::Info_ValueForKey(
            userinfo.as_mut_ptr(),
            b"g_blueteam\x00" as *const u8 as *const libc::c_char,
        ),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong as libc::c_int,
    );
    // send over a subset of the userinfo keys so other clients can
    // print scoreboards, display models, and play custom sounds
    if (*ent).r.svFlags & 0x8 as libc::c_int != 0 {
        s =
            crate::src::qcommon::q_shared::va(b"n\\%s\\t\\%i\\model\\%s\\hmodel\\%s\\c1\\%s\\c2\\%s\\hc\\%i\\w\\%i\\l\\%i\\skill\\%s\\tt\\%d\\tl\\%d\x00"
                   as *const u8 as *const libc::c_char as *mut libc::c_char,
               (*client).pers.netname.as_mut_ptr(),
               (*client).sess.sessionTeam as libc::c_uint, model.as_mut_ptr(),
               headModel.as_mut_ptr(), c1.as_mut_ptr(), c2.as_mut_ptr(),
               (*client).pers.maxHealth, (*client).sess.wins,
               (*client).sess.losses,
               crate::src::qcommon::q_shared::Info_ValueForKey(userinfo.as_mut_ptr(),
                                b"skill\x00" as *const u8 as
                                    *const libc::c_char), teamTask,
               teamLeader)
    } else {
        s =
            crate::src::qcommon::q_shared::va(b"n\\%s\\t\\%i\\model\\%s\\hmodel\\%s\\g_redteam\\%s\\g_blueteam\\%s\\c1\\%s\\c2\\%s\\hc\\%i\\w\\%i\\l\\%i\\tt\\%d\\tl\\%d\x00"
                   as *const u8 as *const libc::c_char as *mut libc::c_char,
               (*client).pers.netname.as_mut_ptr(),
               (*client).sess.sessionTeam as libc::c_uint, model.as_mut_ptr(),
               headModel.as_mut_ptr(), redTeam.as_mut_ptr(),
               blueTeam.as_mut_ptr(), c1.as_mut_ptr(), c2.as_mut_ptr(),
               (*client).pers.maxHealth, (*client).sess.wins,
               (*client).sess.losses, teamTask, teamLeader)
    }
    crate::src::game::g_syscalls::trap_SetConfigstring(
        32 as libc::c_int + 256 as libc::c_int + 256 as libc::c_int + clientNum,
        s,
    );
    // this is not the userinfo, more like the configstring actually
    crate::src::game::g_main::G_LogPrintf(
        b"ClientUserinfoChanged: %i %s\n\x00" as *const u8 as *const libc::c_char,
        clientNum,
        s,
    );
}
/*
===========
ClientConnect

Called when a player begins connecting to the server.
Called again for every map change or tournement restart.

The session information will be valid after exit.

Return NULL if the client should be allowed, otherwise return
a string with the reason for denial.

Otherwise, the client will be sent the current gamestate
and will eventually get to ClientBegin.

firstTime will be qtrue the very first time a client connects
to the server machine, but qfalse on map changes and tournement
restarts.
============
*/
#[no_mangle]

pub unsafe extern "C" fn ClientConnect(
    mut clientNum: libc::c_int,
    mut firstTime: crate::src::qcommon::q_shared::qboolean,
    mut isBot: crate::src::qcommon::q_shared::qboolean,
) -> *mut libc::c_char {
    let mut value: *mut libc::c_char = 0 as *mut libc::c_char;
    //	char		*areabits;
    let mut client: *mut crate::g_local_h::gclient_t = 0 as *mut crate::g_local_h::gclient_t;
    let mut userinfo: [libc::c_char; 1024] = [0; 1024];
    let mut ent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    ent = &mut *crate::src::game::g_main::g_entities
        .as_mut_ptr()
        .offset(clientNum as isize) as *mut crate::g_local_h::gentity_t;
    crate::src::game::g_syscalls::trap_GetUserinfo(
        clientNum,
        userinfo.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong as libc::c_int,
    );
    // IP filtering
    // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=500
    // recommanding PB based IP / GUID banning, the builtin system is pretty limited
    // check to see if they are on the banned IP list
    value = crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"ip\x00" as *const u8 as *const libc::c_char,
    );
    if crate::src::game::g_svcmds::G_FilterPacket(value) as u64 != 0 {
        return b"You are banned from this server.\x00" as *const u8 as *const libc::c_char
            as *mut libc::c_char;
    }
    // we don't check password for bots and local client
    // NOTE: local client <-> "ip" "localhost"
    //   this means this client is not running in our current process
    if isBot as u64 == 0
        && ::libc::strcmp(value, b"localhost\x00" as *const u8 as *const libc::c_char)
            != 0 as libc::c_int
    {
        // check for a password
        value = crate::src::qcommon::q_shared::Info_ValueForKey(
            userinfo.as_mut_ptr(),
            b"password\x00" as *const u8 as *const libc::c_char,
        );
        if crate::src::game::g_main::g_password.string[0 as libc::c_int as usize] as libc::c_int
            != 0
            && crate::src::qcommon::q_shared::Q_stricmp(
                crate::src::game::g_main::g_password.string.as_mut_ptr(),
                b"none\x00" as *const u8 as *const libc::c_char,
            ) != 0
            && ::libc::strcmp(
                crate::src::game::g_main::g_password.string.as_mut_ptr(),
                value,
            ) != 0 as libc::c_int
        {
            return b"Invalid password\x00" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
    }
    // if a player reconnects quickly after a disconnect, the client disconnect may never be called, thus flag can get lost in the ether
    if (*ent).inuse as u64 != 0 {
        crate::src::game::g_main::G_LogPrintf(
            b"Forcing disconnect on active client: %i\n\x00" as *const u8 as *const libc::c_char,
            clientNum,
        );
        // so lets just fix up anything that should happen on a disconnect
        ClientDisconnect(clientNum);
    }
    // they can connect
    (*ent).client = crate::src::game::g_main::level
        .clients
        .offset(clientNum as isize);
    client = (*ent).client;
    //	areabits = client->areabits;
    crate::stdlib::memset(
        client as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<crate::g_local_h::gclient_t>() as libc::c_ulong,
    );
    (*client).pers.connected = crate::g_local_h::CON_CONNECTING;
    // check for local client
    value = crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"ip\x00" as *const u8 as *const libc::c_char,
    );
    if ::libc::strcmp(value, b"localhost\x00" as *const u8 as *const libc::c_char) == 0 {
        (*client).pers.localClient = crate::src::qcommon::q_shared::qtrue
    }
    if isBot as u64 != 0 {
        (*ent).r.svFlags |= 0x8 as libc::c_int;
        (*ent).inuse = crate::src::qcommon::q_shared::qtrue;
        if crate::src::game::g_bot::G_BotConnect(
            clientNum,
            (firstTime as u64 == 0) as libc::c_int as crate::src::qcommon::q_shared::qboolean,
        ) as u64
            == 0
        {
            return b"BotConnectfailed\x00" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
    }
    // read or initialize the session data
    if firstTime as libc::c_uint != 0
        || crate::src::game::g_main::level.newSession as libc::c_uint != 0
    {
        crate::src::game::g_session::G_InitSessionData(
            client as *mut crate::g_local_h::gclient_s,
            userinfo.as_mut_ptr(),
        );
    }
    crate::src::game::g_session::G_ReadSessionData(client as *mut crate::g_local_h::gclient_s);
    // get and distribute relevant parameters
    crate::src::game::g_main::G_LogPrintf(
        b"ClientConnect: %i\n\x00" as *const u8 as *const libc::c_char,
        clientNum,
    );
    ClientUserinfoChanged(clientNum);
    // don't do the "xxx connected" messages if they were caried over from previous level
    if firstTime as u64 != 0 {
        crate::src::game::g_syscalls::trap_SendServerCommand(
            -(1 as libc::c_int),
            crate::src::qcommon::q_shared::va(
                b"print \"%s^7 connected\n\"\x00" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                (*client).pers.netname.as_mut_ptr(),
            ),
        );
    }
    if crate::src::game::g_main::g_gametype.integer >= crate::bg_public_h::GT_TEAM as libc::c_int
        && (*client).sess.sessionTeam as libc::c_uint
            != crate::bg_public_h::TEAM_SPECTATOR as libc::c_int as libc::c_uint
    {
        crate::src::game::g_cmds::BroadcastTeamChange(
            client as *mut crate::g_local_h::gclient_s,
            -(1 as libc::c_int),
        );
    }
    // count current clients and rank for scoreboard
    crate::src::game::g_main::CalculateRanks();
    // for statistics
    //	client->areabits = areabits;
    //	if ( !client->areabits )
    //		client->areabits = G_Alloc( (trap_AAS_PointReachabilityAreaIndex( NULL ) + 7) / 8 );
    return 0 as *mut libc::c_char;
}
/*
===========
ClientBegin

called when a client has finished connecting, and is ready
to be placed into the level.  This will happen every level load,
and on transition between teams, but doesn't happen on respawns
============
*/
#[no_mangle]

pub unsafe extern "C" fn ClientBegin(mut clientNum: libc::c_int) {
    let mut ent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut client: *mut crate::g_local_h::gclient_t = 0 as *mut crate::g_local_h::gclient_t;
    let mut flags: libc::c_int = 0;
    ent = crate::src::game::g_main::g_entities
        .as_mut_ptr()
        .offset(clientNum as isize);
    client = crate::src::game::g_main::level
        .clients
        .offset(clientNum as isize);
    if (*ent).r.linked as u64 != 0 {
        crate::src::game::g_syscalls::trap_UnlinkEntity(ent as *mut crate::g_local_h::gentity_s);
    }
    crate::src::game::g_utils::G_InitGentity(ent as *mut crate::g_local_h::gentity_s);
    (*ent).touch = None;
    (*ent).pain = None;
    (*ent).client = client;
    (*client).pers.connected = crate::g_local_h::CON_CONNECTED;
    (*client).pers.enterTime = crate::src::game::g_main::level.time;
    (*client).pers.teamState.state = crate::g_local_h::TEAM_BEGIN;
    // save eflags around this, because changing teams will
    // cause this to happen with a valid entity, and we
    // want to make sure the teleport bit is set right
    // so the viewpoint doesn't interpolate through the
    // world to the new position
    flags = (*client).ps.eFlags;
    crate::stdlib::memset(
        &mut (*client).ps as *mut crate::src::qcommon::q_shared::playerState_t as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<crate::src::qcommon::q_shared::playerState_t>() as libc::c_ulong,
    );
    (*client).ps.eFlags = flags;
    // locate ent at a spawn point
    ClientSpawn(ent);
    if (*client).sess.sessionTeam as libc::c_uint
        != crate::bg_public_h::TEAM_SPECTATOR as libc::c_int as libc::c_uint
    {
        if crate::src::game::g_main::g_gametype.integer
            != crate::bg_public_h::GT_TOURNAMENT as libc::c_int
        {
            crate::src::game::g_syscalls::trap_SendServerCommand(
                -(1 as libc::c_int),
                crate::src::qcommon::q_shared::va(
                    b"print \"%s^7 entered the game\n\"\x00" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    (*client).pers.netname.as_mut_ptr(),
                ),
            );
        }
    }
    crate::src::game::g_main::G_LogPrintf(
        b"ClientBegin: %i\n\x00" as *const u8 as *const libc::c_char,
        clientNum,
    );
    // count current clients and rank for scoreboard
    crate::src::game::g_main::CalculateRanks();
}
/*
===========
ClientSpawn

Called every time a client is placed fresh in the world:
after the first ClientBegin, and after each respawn
Initializes all non-persistant parts of playerState
============
*/
#[no_mangle]

pub unsafe extern "C" fn ClientSpawn(mut ent: *mut crate::g_local_h::gentity_t) {
    let mut index: libc::c_int = 0;
    let mut spawn_origin: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    let mut spawn_angles: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    let mut client: *mut crate::g_local_h::gclient_t = 0 as *mut crate::g_local_h::gclient_t;
    let mut i: libc::c_int = 0;
    let mut saved: crate::g_local_h::clientPersistant_t = crate::g_local_h::clientPersistant_t {
        connected: crate::g_local_h::CON_DISCONNECTED,
        cmd: crate::src::qcommon::q_shared::usercmd_t {
            serverTime: 0,
            angles: [0; 3],
            buttons: 0,
            weapon: 0,
            forwardmove: 0,
            rightmove: 0,
            upmove: 0,
        },
        localClient: crate::src::qcommon::q_shared::qfalse,
        initialSpawn: crate::src::qcommon::q_shared::qfalse,
        predictItemPickup: crate::src::qcommon::q_shared::qfalse,
        pmoveFixed: crate::src::qcommon::q_shared::qfalse,
        netname: [0; 36],
        maxHealth: 0,
        enterTime: 0,
        teamState: crate::g_local_h::playerTeamState_t {
            state: crate::g_local_h::TEAM_BEGIN,
            location: 0,
            captures: 0,
            basedefense: 0,
            carrierdefense: 0,
            flagrecovery: 0,
            fragcarrier: 0,
            assists: 0,
            lasthurtcarrier: 0.,
            lastreturnedflag: 0.,
            flagsince: 0.,
            lastfraggedcarrier: 0.,
        },
        voteCount: 0,
        teamVoteCount: 0,
        teamInfo: crate::src::qcommon::q_shared::qfalse,
    };
    let mut savedSess: crate::g_local_h::clientSession_t = crate::g_local_h::clientSession_t {
        sessionTeam: crate::bg_public_h::TEAM_FREE,
        spectatorNum: 0,
        spectatorState: crate::g_local_h::SPECTATOR_NOT,
        spectatorClient: 0,
        wins: 0,
        losses: 0,
        teamLeader: crate::src::qcommon::q_shared::qfalse,
    };
    let mut persistant: [libc::c_int; 16] = [0; 16];
    let mut spawnPoint: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut tent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut flags: libc::c_int = 0;
    let mut savedPing: libc::c_int = 0;
    //	char	*savedAreaBits;
    let mut accuracy_hits: libc::c_int = 0;
    let mut accuracy_shots: libc::c_int = 0;
    let mut eventSequence: libc::c_int = 0;
    let mut userinfo: [libc::c_char; 1024] = [0; 1024];
    index = ent.wrapping_offset_from(crate::src::game::g_main::g_entities.as_mut_ptr())
        as libc::c_long as libc::c_int;
    client = (*ent).client;
    spawn_origin[2 as libc::c_int as usize] =
        0 as libc::c_int as crate::src::qcommon::q_shared::vec_t;
    spawn_origin[1 as libc::c_int as usize] = spawn_origin[2 as libc::c_int as usize];
    spawn_origin[0 as libc::c_int as usize] = spawn_origin[1 as libc::c_int as usize];
    // find a spawn point
    // do it before setting health back up, so farthest
    // ranging doesn't count this client
    if (*client).sess.sessionTeam as libc::c_uint
        == crate::bg_public_h::TEAM_SPECTATOR as libc::c_int as libc::c_uint
    {
        spawnPoint = SelectSpectatorSpawnPoint(spawn_origin.as_mut_ptr(), spawn_angles.as_mut_ptr())
    } else if crate::src::game::g_main::g_gametype.integer
        >= crate::bg_public_h::GT_CTF as libc::c_int
    {
        // all base oriented team games use the CTF spawn points
        spawnPoint = crate::src::game::g_team::SelectCTFSpawnPoint(
            (*client).sess.sessionTeam,
            (*client).pers.teamState.state as libc::c_int,
            spawn_origin.as_mut_ptr(),
            spawn_angles.as_mut_ptr(),
            ((*ent).r.svFlags & 0x8 as libc::c_int != 0) as libc::c_int
                as crate::src::qcommon::q_shared::qboolean,
        ) as *mut crate::g_local_h::gentity_s
    } else if (*client).pers.initialSpawn as u64 == 0
        && (*client).pers.localClient as libc::c_uint != 0
    {
        (*client).pers.initialSpawn = crate::src::qcommon::q_shared::qtrue;
        spawnPoint = SelectInitialSpawnPoint(
            spawn_origin.as_mut_ptr(),
            spawn_angles.as_mut_ptr(),
            ((*ent).r.svFlags & 0x8 as libc::c_int != 0) as libc::c_int
                as crate::src::qcommon::q_shared::qboolean,
        )
    } else {
        // the first spawn should be at a good looking spot
        // don't spawn near existing origin if possible
        spawnPoint = SelectSpawnPoint(
            (*client).ps.origin.as_mut_ptr(),
            spawn_origin.as_mut_ptr(),
            spawn_angles.as_mut_ptr(),
            ((*ent).r.svFlags & 0x8 as libc::c_int != 0) as libc::c_int
                as crate::src::qcommon::q_shared::qboolean,
        )
    }
    (*client).pers.teamState.state = crate::g_local_h::TEAM_ACTIVE;
    // always clear the kamikaze flag
    (*ent).s.eFlags &= !(0x200 as libc::c_int);
    // toggle the teleport bit so the client knows to not lerp
    // and never clear the voted flag
    flags = (*(*ent).client).ps.eFlags
        & (0x4 as libc::c_int | 0x4000 as libc::c_int | 0x80000 as libc::c_int);
    flags ^= 0x4 as libc::c_int;
    // clear everything but the persistant data
    saved = (*client).pers;
    savedSess = (*client).sess;
    savedPing = (*client).ps.ping;
    //	savedAreaBits = client->areabits;
    accuracy_hits = (*client).accuracy_hits;
    accuracy_shots = (*client).accuracy_shots;
    i = 0 as libc::c_int;
    while i < 16 as libc::c_int {
        persistant[i as usize] = (*client).ps.persistant[i as usize];
        i += 1
    }
    eventSequence = (*client).ps.eventSequence;
    crate::stdlib::memset(
        client as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<crate::g_local_h::gclient_t>() as libc::c_ulong,
    );
    (*client).pers = saved;
    (*client).sess = savedSess;
    (*client).ps.ping = savedPing;
    //	client->areabits = savedAreaBits;
    (*client).accuracy_hits = accuracy_hits;
    (*client).accuracy_shots = accuracy_shots;
    (*client).lastkilled_client = -(1 as libc::c_int);
    i = 0 as libc::c_int;
    while i < 16 as libc::c_int {
        (*client).ps.persistant[i as usize] = persistant[i as usize];
        i += 1
    }
    (*client).ps.eventSequence = eventSequence;
    // increment the spawncount so the client will detect the respawn
    (*client).ps.persistant[crate::bg_public_h::PERS_SPAWN_COUNT as libc::c_int as usize] += 1;
    (*client).ps.persistant[crate::bg_public_h::PERS_TEAM as libc::c_int as usize] =
        (*client).sess.sessionTeam as libc::c_int;
    (*client).airOutTime = crate::src::game::g_main::level.time + 12000 as libc::c_int;
    crate::src::game::g_syscalls::trap_GetUserinfo(
        index,
        userinfo.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong as libc::c_int,
    );
    // set max health
    (*client).pers.maxHealth = atoi(crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"handicap\x00" as *const u8 as *const libc::c_char,
    ));
    if (*client).pers.maxHealth < 1 as libc::c_int || (*client).pers.maxHealth > 100 as libc::c_int
    {
        (*client).pers.maxHealth = 100 as libc::c_int
    }
    // clear entity values
    (*client).ps.stats[crate::bg_public_h::STAT_MAX_HEALTH as libc::c_int as usize] =
        (*client).pers.maxHealth;
    (*client).ps.eFlags = flags;
    (*ent).s.groundEntityNum = ((1 as libc::c_int) << 10 as libc::c_int) - 1 as libc::c_int;
    (*ent).client = &mut *crate::src::game::g_main::level
        .clients
        .offset(index as isize) as *mut crate::g_local_h::gclient_s;
    (*ent).takedamage = crate::src::qcommon::q_shared::qtrue;
    (*ent).inuse = crate::src::qcommon::q_shared::qtrue;
    (*ent).classname = b"player\x00" as *const u8 as *const libc::c_char as *mut libc::c_char;
    (*ent).r.contents = 0x2000000 as libc::c_int;
    (*ent).clipmask = 1 as libc::c_int | 0x10000 as libc::c_int | 0x2000000 as libc::c_int;
    (*ent).die = Some(
        crate::src::game::g_combat::player_die
            as unsafe extern "C" fn(
                _: *mut crate::g_local_h::gentity_t,
                _: *mut crate::g_local_h::gentity_t,
                _: *mut crate::g_local_h::gentity_t,
                _: libc::c_int,
                _: libc::c_int,
            ) -> (),
    );
    (*ent).waterlevel = 0 as libc::c_int;
    (*ent).watertype = 0 as libc::c_int;
    (*ent).flags = 0 as libc::c_int;
    (*ent).r.mins[0 as libc::c_int as usize] = playerMins[0 as libc::c_int as usize];
    (*ent).r.mins[1 as libc::c_int as usize] = playerMins[1 as libc::c_int as usize];
    (*ent).r.mins[2 as libc::c_int as usize] = playerMins[2 as libc::c_int as usize];
    (*ent).r.maxs[0 as libc::c_int as usize] = playerMaxs[0 as libc::c_int as usize];
    (*ent).r.maxs[1 as libc::c_int as usize] = playerMaxs[1 as libc::c_int as usize];
    (*ent).r.maxs[2 as libc::c_int as usize] = playerMaxs[2 as libc::c_int as usize];
    (*client).ps.clientNum = index;
    (*client).ps.stats[crate::bg_public_h::STAT_WEAPONS as libc::c_int as usize] =
        (1 as libc::c_int) << crate::bg_public_h::WP_MACHINEGUN as libc::c_int;
    if crate::src::game::g_main::g_gametype.integer == crate::bg_public_h::GT_TEAM as libc::c_int {
        (*client).ps.ammo[crate::bg_public_h::WP_MACHINEGUN as libc::c_int as usize] =
            50 as libc::c_int
    } else {
        (*client).ps.ammo[crate::bg_public_h::WP_MACHINEGUN as libc::c_int as usize] =
            100 as libc::c_int
    }
    (*client).ps.stats[crate::bg_public_h::STAT_WEAPONS as libc::c_int as usize] |=
        (1 as libc::c_int) << crate::bg_public_h::WP_GAUNTLET as libc::c_int;
    (*client).ps.ammo[crate::bg_public_h::WP_GAUNTLET as libc::c_int as usize] =
        -(1 as libc::c_int);
    (*client).ps.ammo[crate::bg_public_h::WP_GRAPPLING_HOOK as libc::c_int as usize] =
        -(1 as libc::c_int);
    // health will count down towards max_health
    (*client).ps.stats[crate::bg_public_h::STAT_HEALTH as libc::c_int as usize] =
        (*client).ps.stats[crate::bg_public_h::STAT_MAX_HEALTH as libc::c_int as usize]
            + 25 as libc::c_int;
    (*ent).health = (*client).ps.stats[crate::bg_public_h::STAT_HEALTH as libc::c_int as usize];
    crate::src::game::g_utils::G_SetOrigin(
        ent as *mut crate::g_local_h::gentity_s,
        spawn_origin.as_mut_ptr(),
    );
    (*client).ps.origin[0 as libc::c_int as usize] = spawn_origin[0 as libc::c_int as usize];
    (*client).ps.origin[1 as libc::c_int as usize] = spawn_origin[1 as libc::c_int as usize];
    (*client).ps.origin[2 as libc::c_int as usize] = spawn_origin[2 as libc::c_int as usize];
    // the respawned flag will be cleared after the attack and jump keys come up
    (*client).ps.pm_flags |= 512 as libc::c_int;
    crate::src::game::g_syscalls::trap_GetUsercmd(
        client.wrapping_offset_from(crate::src::game::g_main::level.clients) as libc::c_long
            as libc::c_int,
        &mut (*(*ent).client).pers.cmd as *mut _ as *mut crate::src::qcommon::q_shared::usercmd_s,
    );
    SetClientViewAngle(ent, spawn_angles.as_mut_ptr());
    // don't allow full run speed for a bit
    (*client).ps.pm_flags |= 64 as libc::c_int;
    (*client).ps.pm_time = 100 as libc::c_int;
    (*client).respawnTime = crate::src::game::g_main::level.time;
    (*client).inactivityTime = crate::src::game::g_main::level.time
        + crate::src::game::g_main::g_inactivity.integer * 1000 as libc::c_int;
    (*client).latched_buttons = 0 as libc::c_int;
    // set default animations
    (*client).ps.torsoAnim = crate::bg_public_h::TORSO_STAND as libc::c_int;
    (*client).ps.legsAnim = crate::bg_public_h::LEGS_IDLE as libc::c_int;
    if crate::src::game::g_main::level.intermissiontime == 0 {
        if (*(*ent).client).sess.sessionTeam as libc::c_uint
            != crate::bg_public_h::TEAM_SPECTATOR as libc::c_int as libc::c_uint
        {
            crate::src::game::g_utils::G_KillBox(ent as *mut crate::g_local_h::gentity_s);
            // force the base weapon up
            (*client).ps.weapon = crate::bg_public_h::WP_MACHINEGUN as libc::c_int;
            (*client).ps.weaponstate = crate::bg_public_h::WEAPON_READY as libc::c_int;
            // fire the targets of the spawn point
            crate::src::game::g_utils::G_UseTargets(
                spawnPoint as *mut crate::g_local_h::gentity_s,
                ent as *mut crate::g_local_h::gentity_s,
            );
            // select the highest weapon number available, after any spawn given items have fired
            (*client).ps.weapon = 1 as libc::c_int;
            i = crate::bg_public_h::WP_NUM_WEAPONS as libc::c_int - 1 as libc::c_int;
            while i > 0 as libc::c_int {
                if (*client).ps.stats[crate::bg_public_h::STAT_WEAPONS as libc::c_int as usize]
                    & (1 as libc::c_int) << i
                    != 0
                {
                    (*client).ps.weapon = i;
                    break;
                } else {
                    i -= 1
                }
            }
            // positively link the client, even if the command times are weird
            (*ent).r.currentOrigin[0 as libc::c_int as usize] =
                (*(*ent).client).ps.origin[0 as libc::c_int as usize];
            (*ent).r.currentOrigin[1 as libc::c_int as usize] =
                (*(*ent).client).ps.origin[1 as libc::c_int as usize];
            (*ent).r.currentOrigin[2 as libc::c_int as usize] =
                (*(*ent).client).ps.origin[2 as libc::c_int as usize];
            tent = crate::src::game::g_utils::G_TempEntity(
                (*(*ent).client).ps.origin.as_mut_ptr(),
                crate::bg_public_h::EV_PLAYER_TELEPORT_IN as libc::c_int,
            ) as *mut crate::g_local_h::gentity_s;
            (*tent).s.clientNum = (*ent).s.clientNum;
            crate::src::game::g_syscalls::trap_LinkEntity(ent as *mut crate::g_local_h::gentity_s);
        }
    } else {
        // move players to intermission
        crate::src::game::g_main::MoveClientToIntermission(ent as *mut crate::g_local_h::gentity_s);
    }
    // run a client frame to drop exactly to the floor,
    // initialize animations and other things
    (*client).ps.commandTime = crate::src::game::g_main::level.time - 100 as libc::c_int;
    (*(*ent).client).pers.cmd.serverTime = crate::src::game::g_main::level.time;
    crate::src::game::g_active::ClientThink(
        ent.wrapping_offset_from(crate::src::game::g_main::g_entities.as_mut_ptr()) as libc::c_long
            as libc::c_int,
    );
    // run the presend to set anything else, follow spectators wait
    // until all clients have been reconnected after map_restart
    if (*(*ent).client).sess.spectatorState as libc::c_uint
        != crate::g_local_h::SPECTATOR_FOLLOW as libc::c_int as libc::c_uint
    {
        crate::src::game::g_active::ClientEndFrame(ent as *mut crate::g_local_h::gentity_s);
    }
    // clear entity state values
    crate::src::game::bg_misc::BG_PlayerStateToEntityState(
        &mut (*client).ps as *mut _ as *mut crate::src::qcommon::q_shared::playerState_s,
        &mut (*ent).s as *mut _ as *mut crate::src::qcommon::q_shared::entityState_s,
        crate::src::qcommon::q_shared::qtrue,
    );
}
/*
===========================================================================
Copyright (C) 1999-2005 Id Software, Inc.

This file is part of Quake III Arena source code.

Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Quake III Arena source code; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/
//
// g_local.h -- local definitions for game module
//==================================================================
// the "gameversion" client command will print this plus compile date
// msec
// gentity->flags
// not the first on the team
// spawn point not for bot use
// spawn point just for bots
// force gesture on client
// movers are things like doors, plats, buttons, etc
//============================================================================
// communicated by server to clients
// shared by both the server system and game
// DO NOT MODIFY ANYTHING ABOVE THIS, THE SERVER
// EXPECTS THE FIELDS IN THAT ORDER!
//================================
// NULL if not a client
// set in QuakeEd
// set in QuakeEd
// if true, FreeEntity will only unlink
// bodyque uses this
// FL_* variables
// level.time when the object was freed
// events will be cleared EVENT_VALID_MSEC after set
// if true, it can be pushed by movers and fall off edges
// all game items are physicsObjects,
// 1.0 = continuous bounce, 0.0 = no bounce
// brushes with this content value will be collided against
// when moving.  items and corpses do not collide against
// players, for instance
// movers
// body queue sinking, etc
// movers call this when hitting endpoint
// wind tunnel
// quad will increase this without increasing radius
// next entity in team
// master of the team
// timing variables
// for bonus items
// Beginning a team game, spawn at base
// Now actively playing
// client data that stays across multiple levels or tournament restarts
// this is achieved by writing all the data to cvar strings at game shutdown
// time and reading them back at connection time.  Anything added here
// MUST be dealt with in G_InitSessionData() / G_ReadSessionData() / G_WriteSessionData()
// for determining next-in-line to play
// for chasecam and follow mode
// tournament stats
// true when this client is a team leader
//
// client data that stays across multiple respawns, but is cleared
// on each level change or team change at ClientBegin()
// we would lose angles if not persistant
// true if "ip" info key is "localhost"
// the first spawn should be at a cool location
// based on cg_predictItems userinfo
//
// for handicapping
// level.time the client entered the game
// status in teamplay games
// to prevent people from constantly calling votes
// to prevent people from constantly calling votes
// send team overlay updates?
// this structure is cleared on each ClientSpawn(),
// except for 'client->pers' and 'client->sess'
// ps MUST be the first element, because the server expects it
// communicated by server to clients
// the rest of the structure is private to game
// wishes to leave the intermission
// level.time of last usercmd_t, for EF_CONNECTION
// we can't just use pers.lastCommand.time, because
// of the g_sycronousclients case
// sum up damage over an entire frame, so
// shotgun blasts give a single big kick
// damage absorbed by armor
// damage taken out of health
// impact damage
// origin for vector calculation
// if true, don't use the damage_from vector
// for "impressive" reward sound
// total number of shots
// total number of hits
//
// last client that this client killed
// last client that damaged this client
// type of damage the client did
// timers
// can respawn when time > this, force after g_forcerespwan
// kick players when time > this
// qtrue if the five seoond warning has been given
// clear the EF_AWARD_IMPRESSIVE, etc when time > this
// for multiple kill rewards
// used for hook
// grapple hook if out
// time the player switched teams
// timeResidual is used to handle events that happen every second
// like health / armor countdowns and regeneration
//
// this structure is cleared as each map is entered
//
// [maxclients]
// MAX_CLIENTS <= num_entities <= ENTITYNUM_MAX_NORMAL
// restart match at this time
// store latched cvars here that we want to get at often
// in msec
// so movers can back up when blocked
// level.time the map was started
// last time of client team location update
// don't use any old session data, because
// we changed gametype
// waiting for a map_restart to fire
// includes connecting clients
// connected, non-spectators
// sorted by score
// clientNums for auto-follow spectators
// sound index for standing in lava
// for detecting if g_warmup is changed
// voting state
// level.time vote was called
// time the vote is executed
// set by CalculateRanks
// team voting state
// level.time vote was called
// set by CalculateRanks
// spawn variables
// the G_Spawn*() functions are valid
// key / value pairs
// intermission state
// intermission was qualified, but
// wait INTERMISSION_DELAY_TIME before
// actually going there so the last
// frag can be watched.  Disable future
// kills during this delay
// time the intermission was started
// at least one client wants to exit
// also used for spectator spawns
// target_locations get linked
// head of the location list
// dead bodies
//
// g_spawn.c
//
// spawn string returns a temporary reference, you must CopyString() if you want to keep it
//
// g_cmds.c
//
//
// g_items.c
//
//
// g_utils.c
//
//
// g_combat.c
//
// damage flags
// damage was indirect
// armour does not protect from this damage
// do not affect velocity, just view angles
// armor, shields, invulnerability, and godmode have no effect
//
// g_missile.c
//
//
// g_mover.c
//
//
// g_trigger.c
//
//
// g_misc.c
//
//
// g_weapon.c
//
//
// g_client.c
//
//
// g_svcmds.c
//
//
// g_weapon.c
//
//
// g_cmds.c
//
//
// g_main.c
//
//
// g_client.c
//
/*
===========
ClientDisconnect

Called when a player drops from the server.
Will not be called between levels.

This should NOT be called directly by any game logic,
call trap_DropClient(), which will call this and do
server system housekeeping.
============
*/
#[no_mangle]

pub unsafe extern "C" fn ClientDisconnect(mut clientNum: libc::c_int) {
    let mut ent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut tent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut i: libc::c_int = 0;
    // cleanup if we are kicking a bot that
    // hasn't spawned yet
    crate::src::game::g_bot::G_RemoveQueuedBotBegin(clientNum);
    ent = crate::src::game::g_main::g_entities
        .as_mut_ptr()
        .offset(clientNum as isize);
    if (*ent).client.is_null()
        || (*(*ent).client).pers.connected as libc::c_uint
            == crate::g_local_h::CON_DISCONNECTED as libc::c_int as libc::c_uint
    {
        return;
    }
    // stop any following clients
    i = 0 as libc::c_int;
    while i < crate::src::game::g_main::level.maxclients {
        if (*crate::src::game::g_main::level.clients.offset(i as isize))
            .sess
            .sessionTeam as libc::c_uint
            == crate::bg_public_h::TEAM_SPECTATOR as libc::c_int as libc::c_uint
            && (*crate::src::game::g_main::level.clients.offset(i as isize))
                .sess
                .spectatorState as libc::c_uint
                == crate::g_local_h::SPECTATOR_FOLLOW as libc::c_int as libc::c_uint
            && (*crate::src::game::g_main::level.clients.offset(i as isize))
                .sess
                .spectatorClient
                == clientNum
        {
            crate::src::game::g_cmds::StopFollowing(
                &mut *crate::src::game::g_main::g_entities
                    .as_mut_ptr()
                    .offset(i as isize) as *mut _
                    as *mut crate::g_local_h::gentity_s,
            );
        }
        i += 1
    }
    // send effect if they were completely connected
    if (*(*ent).client).pers.connected as libc::c_uint
        == crate::g_local_h::CON_CONNECTED as libc::c_int as libc::c_uint
        && (*(*ent).client).sess.sessionTeam as libc::c_uint
            != crate::bg_public_h::TEAM_SPECTATOR as libc::c_int as libc::c_uint
    {
        tent = crate::src::game::g_utils::G_TempEntity(
            (*(*ent).client).ps.origin.as_mut_ptr(),
            crate::bg_public_h::EV_PLAYER_TELEPORT_OUT as libc::c_int,
        ) as *mut crate::g_local_h::gentity_s;
        (*tent).s.clientNum = (*ent).s.clientNum;
        // They don't get to take powerups with them!
        // Especially important for stuff like CTF flags
        crate::src::game::g_combat::TossClientItems(ent as *mut crate::g_local_h::gentity_s);
    }
    crate::src::game::g_main::G_LogPrintf(
        b"ClientDisconnect: %i\n\x00" as *const u8 as *const libc::c_char,
        clientNum,
    );
    // if we are playing in tourney mode and losing, give a win to the other player
    if crate::src::game::g_main::g_gametype.integer
        == crate::bg_public_h::GT_TOURNAMENT as libc::c_int
        && crate::src::game::g_main::level.intermissiontime == 0
        && crate::src::game::g_main::level.warmupTime == 0
        && crate::src::game::g_main::level.sortedClients[1 as libc::c_int as usize] == clientNum
    {
        let ref mut fresh3 = (*crate::src::game::g_main::level.clients.offset(
            crate::src::game::g_main::level.sortedClients[0 as libc::c_int as usize] as isize,
        ))
        .sess
        .wins;
        *fresh3 += 1;
        ClientUserinfoChanged(
            crate::src::game::g_main::level.sortedClients[0 as libc::c_int as usize],
        );
    }
    if crate::src::game::g_main::g_gametype.integer
        == crate::bg_public_h::GT_TOURNAMENT as libc::c_int
        && (*(*ent).client).sess.sessionTeam as libc::c_uint
            == crate::bg_public_h::TEAM_FREE as libc::c_int as libc::c_uint
        && crate::src::game::g_main::level.intermissiontime != 0
    {
        crate::src::game::g_syscalls::trap_SendConsoleCommand(
            crate::src::qcommon::q_shared::EXEC_APPEND as libc::c_int,
            b"map_restart 0\n\x00" as *const u8 as *const libc::c_char,
        );
        crate::src::game::g_main::level.restarted = crate::src::qcommon::q_shared::qtrue;
        crate::src::game::g_main::level.changemap = 0 as *mut libc::c_char;
        crate::src::game::g_main::level.intermissiontime = 0 as libc::c_int
    }
    crate::src::game::g_syscalls::trap_UnlinkEntity(ent as *mut crate::g_local_h::gentity_s);
    (*ent).s.modelindex = 0 as libc::c_int;
    (*ent).inuse = crate::src::qcommon::q_shared::qfalse;
    (*ent).classname = b"disconnected\x00" as *const u8 as *const libc::c_char as *mut libc::c_char;
    (*(*ent).client).pers.connected = crate::g_local_h::CON_DISCONNECTED;
    (*(*ent).client).ps.persistant[crate::bg_public_h::PERS_TEAM as libc::c_int as usize] =
        crate::bg_public_h::TEAM_FREE as libc::c_int;
    (*(*ent).client).sess.sessionTeam = crate::bg_public_h::TEAM_FREE;
    crate::src::game::g_syscalls::trap_SetConfigstring(
        32 as libc::c_int + 256 as libc::c_int + 256 as libc::c_int + clientNum,
        b"\x00" as *const u8 as *const libc::c_char,
    );
    crate::src::game::g_main::CalculateRanks();
    if (*ent).r.svFlags & 0x8 as libc::c_int != 0 {
        crate::src::game::ai_main::BotAIShutdownClient(
            clientNum,
            crate::src::qcommon::q_shared::qfalse,
        );
    };
}
