use ::libc;

pub mod q_shared_h {

    /*
    ========================================================================

      ELEMENTS COMMUNICATED ACROSS THE NET

    ========================================================================
    */
    // snapshot used during connection and for zombies
    // toggled every map_restart so transitions can be detected
    //
    // per-level limits
    //
    // absolute limit
    // don't need to send any more
    // entitynums are communicated with GENTITY_BITS, so any reserved
    // values that are going to be communcated over the net need to
    // also be in this range
    // these are sent over the net as 8 bits
    // so they cannot be blindly increased
    // these are the only configstrings that the system reserves, all the
    // other ones are strictly for servergame to clientgame communication
    // an info string with all the serverinfo cvars
    // an info string for server system to client system configuration (timescale, etc)
    // game can't modify below this, only the system can
    //=========================================================
    // bit field limits
    // playerState_t is the information needed by both the client and server
    // to predict player motion and actions
    // nothing outside of pmove should modify these, or some degree of prediction error
    // will occur
    // you can't add anything to this without modifying the code in msg.c
    // playerState_t is a full superset of entityState_t as it is used by players,
    // so if a playerState_t is transmitted, the entityState_t can be fully derived
    // from it.
    // cmd->serverTime of last executed command
    // for view bobbing and footstep generation
    // ducked, jump_held, etc
    // add to command angles to get view direction
    // changed by spawns, rotating objects, and teleporters
    // ENTITYNUM_NONE = in air
    // don't change low priority animations until this runs out
    // mask off ANIM_TOGGLEBIT
    // don't change low priority animations until this runs out
    // mask off ANIM_TOGGLEBIT
    // a number 0 to 7 that represents the relative angle
    // of movement to the view angle (axial and diagonals)
    // when at rest, the value will remain unchanged
    // used to twist the legs during strafing
    // location of grapple to pull towards if PMF_GRAPPLE_PULL
    // copied to entityState_t->eFlags
    // pmove generated events
    // events set on player from another source
    // ranges from 0 to MAX_CLIENTS-1
    // copied to entityState_t->weapon
    // for fixed views
    // damage feedback
    // when it changes, latch the other parms
    // stats that aren't cleared on death
    // level.time that the powerup runs out
    // jumppad entity hit this frame
    // not communicated over the net at all
    // server to game info for scoreboard
    //====================================================================
    //
    // usercmd_t->button bits, many of which are generated by the client system,
    // so they aren't game/cgame only definitions
    //
    // displays talk balloon and disables actions
    // walking can't just be inferred from MOVE_RUN
    // because a key pressed late in the frame will
    // only generate a small move value for that frame
    // walking will use different animations and
    // won't generate footsteps
    // any key whatsoever
    // if forwardmove or rightmove are >= MOVE_RUN,
    // then BUTTON_WALKING should be set
    // usercmd_t is sent to the server each client frame

    // weapon
    // entityState_t is the information conveyed from the server
    // in an update message about entities that the client will
    // need to render in some way
    // Different eTypes may use the information in different ways
    // The messages are delta compressed, so it doesn't really matter if
    // the structure size is fairly large

    #[inline]

    pub unsafe extern "C" fn VectorLength(
        mut v: *const crate::src::qcommon::q_shared::vec_t,
    ) -> crate::src::qcommon::q_shared::vec_t {
        return crate::stdlib::sqrt(
            (*v.offset(0) * *v.offset(0)
                + *v.offset(1) * *v.offset(1)
                + *v.offset(2) * *v.offset(2)) as f64,
        ) as crate::src::qcommon::q_shared::vec_t;
    }

    // entity index
    // entityType_t
    // for calculating position
    // for calculating angles
    // shotgun sources, etc
    // ENTITYNUM_NONE = in air
    // r + (g<<8) + (b<<16) + (intensity<<24)
    // constantly loop this sound
    // 0 to (MAX_CLIENTS - 1), for players and corpses
    // for client side prediction, trap_linkentity sets this properly
    // impulse events -- muzzle flashes, footsteps, etc
    // for players
    // bit flags
    // determines weapon and flash model, etc
    // mask off ANIM_TOGGLEBIT
    // mask off ANIM_TOGGLEBIT
    // __Q_SHARED_H
}

pub mod stdlib_h {
    #[inline]

    pub unsafe extern "C" fn atoi(mut __nptr: *const i8) -> i32 {
        return crate::stdlib::strtol(__nptr, 0 as *mut *mut i8, 10) as i32;
    }
}

pub use crate::stddef_h::size_t;

pub use crate::bg_public_h::gitem_s;
pub use crate::bg_public_h::gitem_t;
pub use crate::bg_public_h::itemType_t;
pub use crate::bg_public_h::team_t;
pub use crate::bg_public_h::C2RustUnnamed_0;
pub use crate::bg_public_h::BOTH_DEAD1;
pub use crate::bg_public_h::BOTH_DEAD2;
pub use crate::bg_public_h::BOTH_DEAD3;
pub use crate::bg_public_h::BOTH_DEATH1;
pub use crate::bg_public_h::BOTH_DEATH2;
pub use crate::bg_public_h::BOTH_DEATH3;
pub use crate::bg_public_h::EV_BULLET;
pub use crate::bg_public_h::EV_BULLET_HIT_FLESH;
pub use crate::bg_public_h::EV_BULLET_HIT_WALL;
pub use crate::bg_public_h::EV_CHANGE_WEAPON;
pub use crate::bg_public_h::EV_DEATH1;
pub use crate::bg_public_h::EV_DEATH2;
pub use crate::bg_public_h::EV_DEATH3;
pub use crate::bg_public_h::EV_DEBUG_LINE;
pub use crate::bg_public_h::EV_FALL_FAR;
pub use crate::bg_public_h::EV_FALL_MEDIUM;
pub use crate::bg_public_h::EV_FALL_SHORT;
pub use crate::bg_public_h::EV_FIRE_WEAPON;
pub use crate::bg_public_h::EV_FOOTSPLASH;
pub use crate::bg_public_h::EV_FOOTSTEP;
pub use crate::bg_public_h::EV_FOOTSTEP_METAL;
pub use crate::bg_public_h::EV_FOOTWADE;
pub use crate::bg_public_h::EV_GENERAL_SOUND;
pub use crate::bg_public_h::EV_GIB_PLAYER;
pub use crate::bg_public_h::EV_GLOBAL_ITEM_PICKUP;
pub use crate::bg_public_h::EV_GLOBAL_SOUND;
pub use crate::bg_public_h::EV_GLOBAL_TEAM_SOUND;
pub use crate::bg_public_h::EV_GRENADE_BOUNCE;
pub use crate::bg_public_h::EV_INVUL_IMPACT;
pub use crate::bg_public_h::EV_ITEM_PICKUP;
pub use crate::bg_public_h::EV_ITEM_POP;
pub use crate::bg_public_h::EV_ITEM_RESPAWN;
pub use crate::bg_public_h::EV_JUICED;
pub use crate::bg_public_h::EV_JUMP;
pub use crate::bg_public_h::EV_JUMP_PAD;
pub use crate::bg_public_h::EV_KAMIKAZE;
pub use crate::bg_public_h::EV_LIGHTNINGBOLT;
pub use crate::bg_public_h::EV_MISSILE_HIT;
pub use crate::bg_public_h::EV_MISSILE_MISS;
pub use crate::bg_public_h::EV_MISSILE_MISS_METAL;
pub use crate::bg_public_h::EV_NOAMMO;
pub use crate::bg_public_h::EV_NONE;
pub use crate::bg_public_h::EV_OBELISKEXPLODE;
pub use crate::bg_public_h::EV_OBELISKPAIN;
pub use crate::bg_public_h::EV_OBITUARY;
pub use crate::bg_public_h::EV_PAIN;
pub use crate::bg_public_h::EV_PLAYER_TELEPORT_IN;
pub use crate::bg_public_h::EV_PLAYER_TELEPORT_OUT;
pub use crate::bg_public_h::EV_POWERUP_BATTLESUIT;
pub use crate::bg_public_h::EV_POWERUP_QUAD;
pub use crate::bg_public_h::EV_POWERUP_REGEN;
pub use crate::bg_public_h::EV_PROXIMITY_MINE_STICK;
pub use crate::bg_public_h::EV_PROXIMITY_MINE_TRIGGER;
pub use crate::bg_public_h::EV_RAILTRAIL;
pub use crate::bg_public_h::EV_SCOREPLUM;
pub use crate::bg_public_h::EV_SHOTGUN;
pub use crate::bg_public_h::EV_STEP_12;
pub use crate::bg_public_h::EV_STEP_16;
pub use crate::bg_public_h::EV_STEP_4;
pub use crate::bg_public_h::EV_STEP_8;
pub use crate::bg_public_h::EV_STOPLOOPINGSOUND;
pub use crate::bg_public_h::EV_SWIM;
pub use crate::bg_public_h::EV_TAUNT;
pub use crate::bg_public_h::EV_TAUNT_FOLLOWME;
pub use crate::bg_public_h::EV_TAUNT_GETFLAG;
pub use crate::bg_public_h::EV_TAUNT_GUARDBASE;
pub use crate::bg_public_h::EV_TAUNT_NO;
pub use crate::bg_public_h::EV_TAUNT_PATROL;
pub use crate::bg_public_h::EV_TAUNT_YES;
pub use crate::bg_public_h::EV_USE_ITEM0;
pub use crate::bg_public_h::EV_USE_ITEM1;
pub use crate::bg_public_h::EV_USE_ITEM10;
pub use crate::bg_public_h::EV_USE_ITEM11;
pub use crate::bg_public_h::EV_USE_ITEM12;
pub use crate::bg_public_h::EV_USE_ITEM13;
pub use crate::bg_public_h::EV_USE_ITEM14;
pub use crate::bg_public_h::EV_USE_ITEM15;
pub use crate::bg_public_h::EV_USE_ITEM2;
pub use crate::bg_public_h::EV_USE_ITEM3;
pub use crate::bg_public_h::EV_USE_ITEM4;
pub use crate::bg_public_h::EV_USE_ITEM5;
pub use crate::bg_public_h::EV_USE_ITEM6;
pub use crate::bg_public_h::EV_USE_ITEM7;
pub use crate::bg_public_h::EV_USE_ITEM8;
pub use crate::bg_public_h::EV_USE_ITEM9;
pub use crate::bg_public_h::EV_WATER_CLEAR;
pub use crate::bg_public_h::EV_WATER_LEAVE;
pub use crate::bg_public_h::EV_WATER_TOUCH;
pub use crate::bg_public_h::EV_WATER_UNDER;
pub use crate::bg_public_h::FLAG_RUN;
pub use crate::bg_public_h::FLAG_STAND;
pub use crate::bg_public_h::FLAG_STAND2RUN;
pub use crate::bg_public_h::GT_1FCTF;
pub use crate::bg_public_h::GT_CTF;
pub use crate::bg_public_h::GT_FFA;
pub use crate::bg_public_h::GT_HARVESTER;
pub use crate::bg_public_h::GT_MAX_GAME_TYPE;
pub use crate::bg_public_h::GT_OBELISK;
pub use crate::bg_public_h::GT_SINGLE_PLAYER;
pub use crate::bg_public_h::GT_TEAM;
pub use crate::bg_public_h::GT_TOURNAMENT;
pub use crate::bg_public_h::IT_AMMO;
pub use crate::bg_public_h::IT_ARMOR;
pub use crate::bg_public_h::IT_BAD;
pub use crate::bg_public_h::IT_HEALTH;
pub use crate::bg_public_h::IT_HOLDABLE;
pub use crate::bg_public_h::IT_PERSISTANT_POWERUP;
pub use crate::bg_public_h::IT_POWERUP;
pub use crate::bg_public_h::IT_TEAM;
pub use crate::bg_public_h::IT_WEAPON;
pub use crate::bg_public_h::LEGS_BACK;
pub use crate::bg_public_h::LEGS_BACKCR;
pub use crate::bg_public_h::LEGS_BACKWALK;
pub use crate::bg_public_h::LEGS_IDLE;
pub use crate::bg_public_h::LEGS_IDLECR;
pub use crate::bg_public_h::LEGS_JUMP;
pub use crate::bg_public_h::LEGS_JUMPB;
pub use crate::bg_public_h::LEGS_LAND;
pub use crate::bg_public_h::LEGS_LANDB;
pub use crate::bg_public_h::LEGS_RUN;
pub use crate::bg_public_h::LEGS_SWIM;
pub use crate::bg_public_h::LEGS_TURN;
pub use crate::bg_public_h::LEGS_WALK;
pub use crate::bg_public_h::LEGS_WALKCR;
pub use crate::bg_public_h::MAX_ANIMATIONS;
pub use crate::bg_public_h::MAX_TOTALANIMATIONS;
pub use crate::bg_public_h::PERS_ASSIST_COUNT;
pub use crate::bg_public_h::PERS_ATTACKEE_ARMOR;
pub use crate::bg_public_h::PERS_ATTACKER;
pub use crate::bg_public_h::PERS_CAPTURES;
pub use crate::bg_public_h::PERS_DEFEND_COUNT;
pub use crate::bg_public_h::PERS_EXCELLENT_COUNT;
pub use crate::bg_public_h::PERS_GAUNTLET_FRAG_COUNT;
pub use crate::bg_public_h::PERS_HITS;
pub use crate::bg_public_h::PERS_IMPRESSIVE_COUNT;
pub use crate::bg_public_h::PERS_KILLED;
pub use crate::bg_public_h::PERS_PLAYEREVENTS;
pub use crate::bg_public_h::PERS_RANK;
pub use crate::bg_public_h::PERS_SCORE;
pub use crate::bg_public_h::PERS_SPAWN_COUNT;
pub use crate::bg_public_h::PERS_TEAM;
pub use crate::bg_public_h::STAT_ARMOR;
pub use crate::bg_public_h::STAT_CLIENTS_READY;
pub use crate::bg_public_h::STAT_DEAD_YAW;
pub use crate::bg_public_h::STAT_HEALTH;
pub use crate::bg_public_h::STAT_HOLDABLE_ITEM;
pub use crate::bg_public_h::STAT_MAX_HEALTH;
pub use crate::bg_public_h::STAT_WEAPONS;
pub use crate::bg_public_h::TEAM_BLUE;
pub use crate::bg_public_h::TEAM_FREE;
pub use crate::bg_public_h::TEAM_NUM_TEAMS;
pub use crate::bg_public_h::TEAM_RED;
pub use crate::bg_public_h::TEAM_SPECTATOR;
pub use crate::bg_public_h::TORSO_AFFIRMATIVE;
pub use crate::bg_public_h::TORSO_ATTACK;
pub use crate::bg_public_h::TORSO_ATTACK2;
pub use crate::bg_public_h::TORSO_DROP;
pub use crate::bg_public_h::TORSO_FOLLOWME;
pub use crate::bg_public_h::TORSO_GESTURE;
pub use crate::bg_public_h::TORSO_GETFLAG;
pub use crate::bg_public_h::TORSO_GUARDBASE;
pub use crate::bg_public_h::TORSO_NEGATIVE;
pub use crate::bg_public_h::TORSO_PATROL;
pub use crate::bg_public_h::TORSO_RAISE;
pub use crate::bg_public_h::TORSO_STAND;
pub use crate::bg_public_h::TORSO_STAND2;
pub use crate::bg_public_h::WEAPON_DROPPING;
pub use crate::bg_public_h::WEAPON_FIRING;
pub use crate::bg_public_h::WEAPON_RAISING;
pub use crate::bg_public_h::WEAPON_READY;
pub use crate::bg_public_h::WP_BFG;
pub use crate::bg_public_h::WP_GAUNTLET;
pub use crate::bg_public_h::WP_GRAPPLING_HOOK;
pub use crate::bg_public_h::WP_GRENADE_LAUNCHER;
pub use crate::bg_public_h::WP_LIGHTNING;
pub use crate::bg_public_h::WP_MACHINEGUN;
pub use crate::bg_public_h::WP_NONE;
pub use crate::bg_public_h::WP_NUM_WEAPONS;
pub use crate::bg_public_h::WP_PLASMAGUN;
pub use crate::bg_public_h::WP_RAILGUN;
pub use crate::bg_public_h::WP_ROCKET_LAUNCHER;
pub use crate::bg_public_h::WP_SHOTGUN;
pub use crate::g_local_h::clientConnected_t;
pub use crate::g_local_h::clientPersistant_t;
pub use crate::g_local_h::clientSession_t;
pub use crate::g_local_h::gclient_s;
pub use crate::g_local_h::gclient_t;
pub use crate::g_local_h::gentity_s;
pub use crate::g_local_h::gentity_t;
pub use crate::g_local_h::level_locals_t;
pub use crate::g_local_h::moverState_t;
pub use crate::g_local_h::playerTeamStateState_t;
pub use crate::g_local_h::playerTeamState_t;
pub use crate::g_local_h::spectatorState_t;
pub use crate::g_local_h::CON_CONNECTED;
pub use crate::g_local_h::CON_CONNECTING;
pub use crate::g_local_h::CON_DISCONNECTED;
pub use crate::g_local_h::MOVER_1TO2;
pub use crate::g_local_h::MOVER_2TO1;
pub use crate::g_local_h::MOVER_POS1;
pub use crate::g_local_h::MOVER_POS2;
pub use crate::g_local_h::SPECTATOR_FOLLOW;
pub use crate::g_local_h::SPECTATOR_FREE;
pub use crate::g_local_h::SPECTATOR_NOT;
pub use crate::g_local_h::SPECTATOR_SCOREBOARD;
pub use crate::g_local_h::TEAM_ACTIVE;
pub use crate::g_local_h::TEAM_BEGIN;
pub use crate::g_public_h::entityShared_t;
pub use crate::src::game::ai_main::BotAIShutdownClient;
pub use crate::src::game::bg_misc::BG_PlayerStateToEntityState;
pub use crate::src::game::g_active::ClientEndFrame;
pub use crate::src::game::g_active::ClientThink;
pub use crate::src::game::g_bot::G_BotConnect;
pub use crate::src::game::g_bot::G_RemoveQueuedBotBegin;
pub use crate::src::game::g_client::q_shared_h::VectorLength;
pub use crate::src::game::g_cmds::BroadcastTeamChange;
pub use crate::src::game::g_cmds::StopFollowing;
pub use crate::src::game::g_combat::body_die;
pub use crate::src::game::g_combat::player_die;
pub use crate::src::game::g_combat::TossClientItems;
pub use crate::src::game::g_main::g_entities;
pub use crate::src::game::g_main::g_gametype;
pub use crate::src::game::g_main::g_inactivity;
pub use crate::src::game::g_main::g_password;
pub use crate::src::game::g_main::level;
pub use crate::src::game::g_main::CalculateRanks;
pub use crate::src::game::g_main::FindIntermissionPoint;
pub use crate::src::game::g_main::G_Error;
pub use crate::src::game::g_main::G_LogPrintf;
pub use crate::src::game::g_main::MoveClientToIntermission;
pub use crate::src::game::g_session::G_InitSessionData;
pub use crate::src::game::g_session::G_ReadSessionData;
pub use crate::src::game::g_spawn::G_SpawnInt;
pub use crate::src::game::g_svcmds::G_FilterPacket;
pub use crate::src::game::g_syscalls::trap_DropClient;
pub use crate::src::game::g_syscalls::trap_EntitiesInBox;
pub use crate::src::game::g_syscalls::trap_GetUsercmd;
pub use crate::src::game::g_syscalls::trap_GetUserinfo;
pub use crate::src::game::g_syscalls::trap_LinkEntity;
pub use crate::src::game::g_syscalls::trap_PointContents;
pub use crate::src::game::g_syscalls::trap_SendConsoleCommand;
pub use crate::src::game::g_syscalls::trap_SendServerCommand;
pub use crate::src::game::g_syscalls::trap_SetConfigstring;
pub use crate::src::game::g_syscalls::trap_UnlinkEntity;
pub use crate::src::game::g_utils::G_Find;
pub use crate::src::game::g_utils::G_InitGentity;
pub use crate::src::game::g_utils::G_KillBox;
pub use crate::src::game::g_utils::G_SetOrigin;
pub use crate::src::game::g_utils::G_Spawn;
pub use crate::src::game::g_utils::G_TempEntity;
pub use crate::src::game::g_utils::G_UseTargets;
pub use crate::src::qcommon::q_math::vec3_origin;
pub use crate::src::qcommon::q_shared::byte;
pub use crate::src::qcommon::q_shared::cplane_s;
pub use crate::src::qcommon::q_shared::cplane_t;
pub use crate::src::qcommon::q_shared::cvarHandle_t;
pub use crate::src::qcommon::q_shared::entityState_s;
pub use crate::src::qcommon::q_shared::entityState_t;
pub use crate::src::qcommon::q_shared::fileHandle_t;
pub use crate::src::qcommon::q_shared::playerState_s;
pub use crate::src::qcommon::q_shared::playerState_t;
pub use crate::src::qcommon::q_shared::qboolean;
pub use crate::src::qcommon::q_shared::qfalse;
pub use crate::src::qcommon::q_shared::qtrue;
pub use crate::src::qcommon::q_shared::trType_t;
pub use crate::src::qcommon::q_shared::trace_t;
pub use crate::src::qcommon::q_shared::trajectory_t;
pub use crate::src::qcommon::q_shared::usercmd_s;
pub use crate::src::qcommon::q_shared::usercmd_t;
pub use crate::src::qcommon::q_shared::va;
pub use crate::src::qcommon::q_shared::vec3_t;
pub use crate::src::qcommon::q_shared::vec_t;
pub use crate::src::qcommon::q_shared::vmCvar_t;
pub use crate::src::qcommon::q_shared::Info_Validate;
pub use crate::src::qcommon::q_shared::Info_ValueForKey;
pub use crate::src::qcommon::q_shared::Q_IsColorString;
pub use crate::src::qcommon::q_shared::Q_stricmp;
pub use crate::src::qcommon::q_shared::Q_strncpyz;
pub use crate::src::qcommon::q_shared::EXEC_APPEND;
pub use crate::src::qcommon::q_shared::EXEC_INSERT;
pub use crate::src::qcommon::q_shared::EXEC_NOW;
pub use crate::src::qcommon::q_shared::TR_GRAVITY;
pub use crate::src::qcommon::q_shared::TR_INTERPOLATE;
pub use crate::src::qcommon::q_shared::TR_LINEAR;
pub use crate::src::qcommon::q_shared::TR_LINEAR_STOP;
pub use crate::src::qcommon::q_shared::TR_SINE;
pub use crate::src::qcommon::q_shared::TR_STATIONARY;

pub use crate::src::game::g_client::stdlib_h::atoi;

pub use crate::stdlib::rand;

pub use crate::stdlib::strtol;
/*
===========================================================================
Copyright (C) 1999-2005 Id Software, Inc.

This file is part of Quake III Arena source code.

Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Quake III Arena source code; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/
//
// g_client.c -- client functions that don't happen every frame

static mut playerMins: crate::src::qcommon::q_shared::vec3_t = [-15f32, -15f32, -24f32];

static mut playerMaxs: crate::src::qcommon::q_shared::vec3_t = [15f32, 15f32, 32f32];
/*QUAKED info_player_deathmatch (1 0 1) (-16 -16 -24) (16 16 32) initial
potential spawning position for deathmatch games.
The first time a player enters the game, they will be at an 'initial' spot.
Targets will be fired when someone spawns in on them.
"nobots" will prevent bots from using this spot.
"nohumans" will prevent non-bots from using this spot.
*/
#[no_mangle]

pub unsafe extern "C" fn SP_info_player_deathmatch(mut ent: *mut crate::g_local_h::gentity_t) {
    let mut i: i32 = 0;
    crate::src::game::g_spawn::G_SpawnInt(
        b"nobots\x00" as *const u8 as *const i8,
        b"0\x00" as *const u8 as *const i8,
        &mut i,
    );
    if i != 0 {
        (*ent).flags |= 0x2000
    }
    crate::src::game::g_spawn::G_SpawnInt(
        b"nohumans\x00" as *const u8 as *const i8,
        b"0\x00" as *const u8 as *const i8,
        &mut i,
    );
    if i != 0 {
        (*ent).flags |= 0x4000
    };
}
/*QUAKED info_player_start (1 0 0) (-16 -16 -24) (16 16 32)
equivalent to info_player_deathmatch
*/
#[no_mangle]

pub unsafe extern "C" fn SP_info_player_start(mut ent: *mut crate::g_local_h::gentity_t) {
    (*ent).classname = b"info_player_deathmatch\x00" as *const u8 as *mut i8;
    SP_info_player_deathmatch(ent);
}
/*QUAKED info_player_intermission (1 0 1) (-16 -16 -24) (16 16 32)
The intermission will be viewed from this point.  Target an info_notnull for the view direction.
*/
#[no_mangle]

pub unsafe extern "C" fn SP_info_player_intermission(mut _ent: *mut crate::g_local_h::gentity_t) {}
/*
=======================================================================

  SelectSpawnPoint

=======================================================================
*/
/*
================
SpotWouldTelefrag

================
*/
#[no_mangle]

pub unsafe extern "C" fn SpotWouldTelefrag(
    mut spot: *mut crate::g_local_h::gentity_t,
) -> crate::src::qcommon::q_shared::qboolean {
    let mut _i: i32 = 0;
    let mut num: i32 = 0;
    let mut touch: [i32; 1024] = [0; 1024];
    let mut hit: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut mins: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    let mut maxs: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    mins[0] = (*spot).s.origin[0] + playerMins[0];
    mins[1] = (*spot).s.origin[1] + playerMins[1];
    mins[2] = (*spot).s.origin[2] + playerMins[2];
    maxs[0] = (*spot).s.origin[0] + playerMaxs[0];
    maxs[1] = (*spot).s.origin[1] + playerMaxs[1];
    maxs[2] = (*spot).s.origin[2] + playerMaxs[2];
    num = crate::src::game::g_syscalls::trap_EntitiesInBox(
        mins.as_mut_ptr() as *const crate::src::qcommon::q_shared::vec_t,
        maxs.as_mut_ptr() as *const crate::src::qcommon::q_shared::vec_t,
        touch.as_mut_ptr(),
        (1) << 10,
    );

    for i in 0..num {
        hit = &mut *crate::src::game::g_main::g_entities
            .as_mut_ptr()
            .offset(*touch.as_mut_ptr().offset(i as isize) as isize)
            as *mut crate::g_local_h::gentity_t;

        if !(*hit).client.is_null() {
            return crate::src::qcommon::q_shared::qtrue;
        }
    }
    return crate::src::qcommon::q_shared::qfalse;
}
/*
================
SelectNearestDeathmatchSpawnPoint

Find the spot that we DON'T want to use
================
*/
#[no_mangle]

pub unsafe extern "C" fn SelectNearestDeathmatchSpawnPoint(
    mut from: *mut crate::src::qcommon::q_shared::vec_t,
) -> *mut crate::g_local_h::gentity_t {
    let mut spot: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut delta: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    let mut dist: f32 = 0.;
    let mut nearestDist: f32 = 0.;
    let mut nearestSpot: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    nearestDist = 999999f32;
    nearestSpot = 0 as *mut crate::g_local_h::gentity_t;
    spot = 0 as *mut crate::g_local_h::gentity_t;
    loop {
        spot = crate::src::game::g_utils::G_Find(
            spot,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut i8 as i32,
            b"info_player_deathmatch\x00" as *const u8 as *const i8,
        );
        if spot.is_null() {
            break;
        }
        delta[0] = (*spot).s.origin[0] - *from.offset(0);
        delta[1] = (*spot).s.origin[1] - *from.offset(1);
        delta[2] = (*spot).s.origin[2] - *from.offset(2);
        dist = VectorLength(delta.as_mut_ptr() as *const crate::src::qcommon::q_shared::vec_t);
        if dist < nearestDist {
            nearestDist = dist;
            nearestSpot = spot
        }
    }
    return nearestSpot;
}
#[no_mangle]

pub unsafe extern "C" fn SelectRandomDeathmatchSpawnPoint(
    mut isbot: crate::src::qcommon::q_shared::qboolean,
) -> *mut crate::g_local_h::gentity_t {
    let mut spot: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut count: i32 = 0;
    let mut selection: i32 = 0;
    let mut spots: [*mut crate::g_local_h::gentity_t; 128] =
        [0 as *mut crate::g_local_h::gentity_t; 128];
    count = 0;
    spot = 0 as *mut crate::g_local_h::gentity_t;
    loop
    // spot is not for this human/bot player
    {
        spot = crate::src::game::g_utils::G_Find(
            spot,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut i8 as i32,
            b"info_player_deathmatch\x00" as *const u8 as *const i8,
        );
        if !(!spot.is_null() && count < 128) {
            break;
        }
        if SpotWouldTelefrag(spot) as u64 != 0 {
            continue;
        }
        if (*spot).flags & 0x2000 != 0 && isbot != 0
            || (*spot).flags & 0x4000 != 0 && isbot as u64 == 0
        {
            continue;
        }
        spots[count as usize] = spot;
        count += 1
    }
    if count == 0 {
        // no spots that won't telefrag
        return crate::src::game::g_utils::G_Find(
            0 as *mut crate::g_local_h::gentity_t,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut i8 as i32,
            b"info_player_deathmatch\x00" as *const u8 as *const i8,
        );
    }
    selection = crate::stdlib::rand() % count;
    return spots[selection as usize];
}
/*
===========
SelectRandomFurthestSpawnPoint

Chooses a player start, deathmatch start, etc
============
*/
#[no_mangle]

pub unsafe extern "C" fn SelectRandomFurthestSpawnPoint(
    mut avoidPoint: *mut crate::src::qcommon::q_shared::vec_t,
    mut origin: *mut crate::src::qcommon::q_shared::vec_t,
    mut angles: *mut crate::src::qcommon::q_shared::vec_t,
    mut isbot: crate::src::qcommon::q_shared::qboolean,
) -> *mut crate::g_local_h::gentity_t {
    let mut spot: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut delta: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    let mut dist: f32 = 0.;
    let mut list_dist: [f32; 128] = [0.; 128];
    let mut list_spot: [*mut crate::g_local_h::gentity_t; 128] =
        [0 as *mut crate::g_local_h::gentity_t; 128];
    let mut numSpots: i32 = 0;
    let mut rnd: i32 = 0;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    numSpots = 0;
    spot = 0 as *mut crate::g_local_h::gentity_t;
    loop
    // spot is not for this human/bot player
    {
        spot = crate::src::game::g_utils::G_Find(
            spot,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut i8 as i32,
            b"info_player_deathmatch\x00" as *const u8 as *const i8,
        );
        if spot.is_null() {
            break;
        }
        if SpotWouldTelefrag(spot) as u64 != 0 {
            continue;
        }
        if (*spot).flags & 0x2000 != 0 && isbot != 0
            || (*spot).flags & 0x4000 != 0 && isbot as u64 == 0
        {
            continue;
        }
        delta[0] = (*spot).s.origin[0] - *avoidPoint.offset(0);
        delta[1] = (*spot).s.origin[1] - *avoidPoint.offset(1);
        delta[2] = (*spot).s.origin[2] - *avoidPoint.offset(2);
        dist = VectorLength(delta.as_mut_ptr() as *const crate::src::qcommon::q_shared::vec_t);
        i = 0;
        while i < numSpots {
            if dist > list_dist[i as usize] {
                if numSpots >= 128 {
                    numSpots = 128 - 1
                }
                j = numSpots;
                while j > i {
                    list_dist[j as usize] = list_dist[(j - 1) as usize];
                    list_spot[j as usize] = list_spot[(j - 1) as usize];
                    j -= 1
                }
                list_dist[i as usize] = dist;
                list_spot[i as usize] = spot;
                numSpots += 1;
                break;
            } else {
                i += 1
            }
        }
        if i >= numSpots && numSpots < 128 {
            list_dist[numSpots as usize] = dist;
            list_spot[numSpots as usize] = spot;
            numSpots += 1
        }
    }
    if numSpots == 0 {
        spot = crate::src::game::g_utils::G_Find(
            0 as *mut crate::g_local_h::gentity_t,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut i8 as i32,
            b"info_player_deathmatch\x00" as *const u8 as *const i8,
        );
        if spot.is_null() {
            crate::src::game::g_main::G_Error(
                b"Couldn\'t find a spawn point\x00" as *const u8 as *const i8,
            );
        }
        *origin.offset(0) = (*spot).s.origin[0];
        *origin.offset(1) = (*spot).s.origin[1];
        *origin.offset(2) = (*spot).s.origin[2];
        let ref mut fresh0 = *origin.offset(2);
        *fresh0 += 9f32;
        *angles.offset(0) = (*spot).s.angles[0];
        *angles.offset(1) = (*spot).s.angles[1];
        *angles.offset(2) = (*spot).s.angles[2];
        return spot;
    }
    // select a random spot from the spawn points furthest away
    rnd = ((crate::stdlib::rand() & 0x7fff) as f32 / 32767f32 * (numSpots / 2) as f32) as i32;
    *origin.offset(0) = (*list_spot[rnd as usize]).s.origin[0];
    *origin.offset(1) = (*list_spot[rnd as usize]).s.origin[1];
    *origin.offset(2) = (*list_spot[rnd as usize]).s.origin[2];
    let ref mut fresh1 = *origin.offset(2);
    *fresh1 += 9f32;
    *angles.offset(0) = (*list_spot[rnd as usize]).s.angles[0];
    *angles.offset(1) = (*list_spot[rnd as usize]).s.angles[1];
    *angles.offset(2) = (*list_spot[rnd as usize]).s.angles[2];
    return list_spot[rnd as usize];
}
/*
===========
SelectSpawnPoint

Chooses a player start, deathmatch start, etc
============
*/
#[no_mangle]

pub unsafe extern "C" fn SelectSpawnPoint(
    mut avoidPoint: *mut crate::src::qcommon::q_shared::vec_t,
    mut origin: *mut crate::src::qcommon::q_shared::vec_t,
    mut angles: *mut crate::src::qcommon::q_shared::vec_t,
    mut isbot: crate::src::qcommon::q_shared::qboolean,
) -> *mut crate::g_local_h::gentity_t {
    return SelectRandomFurthestSpawnPoint(avoidPoint, origin, angles, isbot);
    /*
    gentity_t	*spot;
    gentity_t	*nearestSpot;

    nearestSpot = SelectNearestDeathmatchSpawnPoint( avoidPoint );

    spot = SelectRandomDeathmatchSpawnPoint ( );
    if ( spot == nearestSpot ) {
        // roll again if it would be real close to point of death
        spot = SelectRandomDeathmatchSpawnPoint ( );
        if ( spot == nearestSpot ) {
            // last try
            spot = SelectRandomDeathmatchSpawnPoint ( );
        }
    }

    // find a single player start spot
    if (!spot) {
        G_Error( "Couldn't find a spawn point" );
    }

    VectorCopy (spot->s.origin, origin);
    origin[2] += 9;
    VectorCopy (spot->s.angles, angles);

    return spot;
    */
}
/*
===========
SelectInitialSpawnPoint

Try to find a spawn point marked 'initial', otherwise
use normal spawn selection.
============
*/
#[no_mangle]

pub unsafe extern "C" fn SelectInitialSpawnPoint(
    mut origin: *mut crate::src::qcommon::q_shared::vec_t,
    mut angles: *mut crate::src::qcommon::q_shared::vec_t,
    mut isbot: crate::src::qcommon::q_shared::qboolean,
) -> *mut crate::g_local_h::gentity_t {
    let mut spot: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    spot = 0 as *mut crate::g_local_h::gentity_t;
    loop {
        spot = crate::src::game::g_utils::G_Find(
            spot,
            &mut (*(0 as *mut crate::g_local_h::gentity_t)).classname as *mut *mut i8 as i32,
            b"info_player_deathmatch\x00" as *const u8 as *const i8,
        );
        if spot.is_null() {
            break;
        }
        if (*spot).flags & 0x2000 != 0 && isbot != 0
            || (*spot).flags & 0x4000 != 0 && isbot as u64 == 0
        {
            continue;
        }
        if (*spot).spawnflags & 0x1 != 0 {
            break;
        }
    }
    if spot.is_null() || SpotWouldTelefrag(spot) != 0 {
        return SelectSpawnPoint(
            crate::src::qcommon::q_math::vec3_origin.as_mut_ptr(),
            origin,
            angles,
            isbot,
        );
    }
    *origin.offset(0) = (*spot).s.origin[0];
    *origin.offset(1) = (*spot).s.origin[1];
    *origin.offset(2) = (*spot).s.origin[2];
    let ref mut fresh2 = *origin.offset(2);
    *fresh2 += 9f32;
    *angles.offset(0) = (*spot).s.angles[0];
    *angles.offset(1) = (*spot).s.angles[1];
    *angles.offset(2) = (*spot).s.angles[2];
    return spot;
}
/*
===========
SelectSpectatorSpawnPoint

============
*/
#[no_mangle]

pub unsafe extern "C" fn SelectSpectatorSpawnPoint(
    mut origin: *mut crate::src::qcommon::q_shared::vec_t,
    mut angles: *mut crate::src::qcommon::q_shared::vec_t,
) -> *mut crate::g_local_h::gentity_t {
    crate::src::game::g_main::FindIntermissionPoint();
    *origin.offset(0) = crate::src::game::g_main::level.intermission_origin[0];
    *origin.offset(1) = crate::src::game::g_main::level.intermission_origin[1];
    *origin.offset(2) = crate::src::game::g_main::level.intermission_origin[2];
    *angles.offset(0) = crate::src::game::g_main::level.intermission_angle[0];
    *angles.offset(1) = crate::src::game::g_main::level.intermission_angle[1];
    *angles.offset(2) = crate::src::game::g_main::level.intermission_angle[2];
    return 0 as *mut crate::g_local_h::gentity_t;
}
/*
=======================================================================

BODYQUE

=======================================================================
*/
/*
===============
InitBodyQue
===============
*/
#[no_mangle]

pub unsafe extern "C" fn InitBodyQue() {
    let mut i: i32 = 0;
    let mut ent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    crate::src::game::g_main::level.bodyQueIndex = 0;
    i = 0;
    while i < 8 {
        ent = crate::src::game::g_utils::G_Spawn();
        (*ent).classname = b"bodyque\x00" as *const u8 as *mut i8;
        (*ent).neverFree = crate::src::qcommon::q_shared::qtrue;
        crate::src::game::g_main::level.bodyQue[i as usize] = ent;
        i += 1
    }
}
/*
=============
BodySink

After sitting around for five seconds, fall into the ground and disappear
=============
*/
#[no_mangle]

pub unsafe extern "C" fn BodySink(mut ent: *mut crate::g_local_h::gentity_t) {
    if crate::src::game::g_main::level.time - (*ent).timestamp > 6500 {
        // the body ques are never actually freed, they are just unlinked
        crate::src::game::g_syscalls::trap_UnlinkEntity(ent);
        (*ent).physicsObject = crate::src::qcommon::q_shared::qfalse;
        return;
    }
    (*ent).nextthink = crate::src::game::g_main::level.time + 100;
    (*ent).s.pos.trBase[2] -= 1f32;
}
/*
=============
CopyToBodyQue

A player is respawning, so make an entity that looks
just like the existing corpse to leave behind.
=============
*/
#[no_mangle]

pub unsafe extern "C" fn CopyToBodyQue(mut ent: *mut crate::g_local_h::gentity_t) {
    let mut body: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut contents: i32 = 0;
    crate::src::game::g_syscalls::trap_UnlinkEntity(ent);
    // if client is in a nodrop area, don't leave the body
    contents = crate::src::game::g_syscalls::trap_PointContents(
        (*ent).s.origin.as_mut_ptr() as *const crate::src::qcommon::q_shared::vec_t,
        -(1),
    );
    if contents as u32 & 0x80000000 != 0 {
        return;
    }
    // grab a body que and cycle to the next one
    body = crate::src::game::g_main::level.bodyQue
        [crate::src::game::g_main::level.bodyQueIndex as usize]; // clear EF_TALK, etc
    crate::src::game::g_main::level.bodyQueIndex =
        (crate::src::game::g_main::level.bodyQueIndex + 1) % 8; // clear powerups
    (*body).s = (*ent).s; // clear lava burning
    (*body).s.eFlags = 0x1; // don't bounce
    (*body).s.powerups = 0;
    (*body).s.loopSound = 0;
    (*body).s.number =
        body.wrapping_offset_from(crate::src::game::g_main::g_entities.as_mut_ptr()) as i32;
    (*body).timestamp = crate::src::game::g_main::level.time;
    (*body).physicsObject = crate::src::qcommon::q_shared::qtrue;
    (*body).physicsBounce = 0f32;
    if (*body).s.groundEntityNum == ((1) << 10) - 1 {
        (*body).s.pos.trType = crate::src::qcommon::q_shared::TR_GRAVITY;
        (*body).s.pos.trTime = crate::src::game::g_main::level.time;
        (*body).s.pos.trDelta[0] = (*(*ent).client).ps.velocity[0];
        (*body).s.pos.trDelta[1] = (*(*ent).client).ps.velocity[1];
        (*body).s.pos.trDelta[2] = (*(*ent).client).ps.velocity[2]
    } else {
        (*body).s.pos.trType = crate::src::qcommon::q_shared::TR_STATIONARY
    }
    (*body).s.event = 0;
    // change the animation to the last-frame only, so the sequence
    // doesn't repeat anew for the body
    match (*body).s.legsAnim & !(128) {
        0 | 1 => {
            (*body).s.legsAnim = crate::bg_public_h::BOTH_DEAD1 as i32;
            (*body).s.torsoAnim = (*body).s.legsAnim
        }
        2 | 3 => {
            (*body).s.legsAnim = crate::bg_public_h::BOTH_DEAD2 as i32;
            (*body).s.torsoAnim = (*body).s.legsAnim
        }
        4 | 5 | _ => {
            (*body).s.legsAnim = crate::bg_public_h::BOTH_DEAD3 as i32;
            (*body).s.torsoAnim = (*body).s.legsAnim
        }
    }
    (*body).r.svFlags = (*ent).r.svFlags;
    (*body).r.mins[0] = (*ent).r.mins[0];
    (*body).r.mins[1] = (*ent).r.mins[1];
    (*body).r.mins[2] = (*ent).r.mins[2];
    (*body).r.maxs[0] = (*ent).r.maxs[0];
    (*body).r.maxs[1] = (*ent).r.maxs[1];
    (*body).r.maxs[2] = (*ent).r.maxs[2];
    (*body).r.absmin[0] = (*ent).r.absmin[0];
    (*body).r.absmin[1] = (*ent).r.absmin[1];
    (*body).r.absmin[2] = (*ent).r.absmin[2];
    (*body).r.absmax[0] = (*ent).r.absmax[0];
    (*body).r.absmax[1] = (*ent).r.absmax[1];
    (*body).r.absmax[2] = (*ent).r.absmax[2];
    (*body).clipmask = 1 | 0x10000;
    (*body).r.contents = 0x4000000;
    (*body).r.ownerNum = (*ent).s.number;
    (*body).nextthink = crate::src::game::g_main::level.time + 5000;
    (*body).think =
        Some(BodySink as unsafe extern "C" fn(_: *mut crate::g_local_h::gentity_t) -> ());
    (*body).die = Some(
        crate::src::game::g_combat::body_die
            as unsafe extern "C" fn(
                _: *mut crate::g_local_h::gentity_t,
                _: *mut crate::g_local_h::gentity_t,
                _: *mut crate::g_local_h::gentity_t,
                _: i32,
                _: i32,
            ) -> (),
    );
    // don't take more damage if already gibbed
    if (*ent).health <= -(40) {
        (*body).takedamage = crate::src::qcommon::q_shared::qfalse
    } else {
        (*body).takedamage = crate::src::qcommon::q_shared::qtrue
    }
    (*body).r.currentOrigin[0] = (*body).s.pos.trBase[0];
    (*body).r.currentOrigin[1] = (*body).s.pos.trBase[1];
    (*body).r.currentOrigin[2] = (*body).s.pos.trBase[2];
    crate::src::game::g_syscalls::trap_LinkEntity(body);
}
//======================================================================
/*
==================
SetClientViewAngle

==================
*/
#[no_mangle]

pub unsafe extern "C" fn SetClientViewAngle(
    mut ent: *mut crate::g_local_h::gentity_t,
    mut angle: *mut crate::src::qcommon::q_shared::vec_t,
) {
    let mut _i: i32 = 0;
    // set the delta angle

    for i in 0..3 {
        let mut cmdAngle: i32 = 0;

        cmdAngle = (*angle.offset(i as isize) * 65536f32 / 360f32) as i32 & 65535;

        (*(*ent).client).ps.delta_angles[i as usize] =
            cmdAngle - (*(*ent).client).pers.cmd.angles[i as usize];
    }
    (*ent).s.angles[0] = *angle.offset(0);
    (*ent).s.angles[1] = *angle.offset(1);
    (*ent).s.angles[2] = *angle.offset(2);
    (*(*ent).client).ps.viewangles[0] = (*ent).s.angles[0];
    (*(*ent).client).ps.viewangles[1] = (*ent).s.angles[1];
    (*(*ent).client).ps.viewangles[2] = (*ent).s.angles[2];
}
/*
================
ClientRespawn
================
*/
#[no_mangle]

pub unsafe extern "C" fn ClientRespawn(mut ent: *mut crate::g_local_h::gentity_t) {
    CopyToBodyQue(ent);
    ClientSpawn(ent);
}
/*
================
TeamCount

Returns number of players on a team
================
*/
#[no_mangle]

pub unsafe extern "C" fn TeamCount(
    mut ignoreClientNum: i32,
    mut team: crate::bg_public_h::team_t,
) -> i32 {
    let mut _i: i32 = 0;
    let mut count: i32 = 0;

    for i in 0..crate::src::game::g_main::level.maxclients {
        if !(i == ignoreClientNum) {
            if !((*crate::src::game::g_main::level.clients.offset(i as isize))
                .pers
                .connected
                == crate::g_local_h::CON_DISCONNECTED)
            {
                if (*crate::src::game::g_main::level.clients.offset(i as isize))
                    .sess
                    .sessionTeam
                    == team
                {
                    count += 1
                }
            }
        }
    }
    return count;
}
/*
================
TeamLeader

Returns the client number of the team leader
================
*/
#[no_mangle]

pub unsafe extern "C" fn TeamLeader(mut team: i32) -> i32 {
    let mut _i: i32 = 0;

    for i in 0..crate::src::game::g_main::level.maxclients {
        if !((*crate::src::game::g_main::level.clients.offset(i as isize))
            .pers
            .connected
            == crate::g_local_h::CON_DISCONNECTED)
        {
            if (*crate::src::game::g_main::level.clients.offset(i as isize))
                .sess
                .sessionTeam
                == team as u32
            {
                if (*crate::src::game::g_main::level.clients.offset(i as isize))
                    .sess
                    .teamLeader as u64
                    != 0
                {
                    return i;
                }
            }
        }
    }
    return -(1);
}
/*
================
PickTeam

================
*/
#[no_mangle]

pub unsafe extern "C" fn PickTeam(mut ignoreClientNum: i32) -> crate::bg_public_h::team_t {
    let mut counts: [i32; 4] = [0; 4];
    counts[crate::bg_public_h::TEAM_BLUE as usize] =
        TeamCount(ignoreClientNum, crate::bg_public_h::TEAM_BLUE);
    counts[crate::bg_public_h::TEAM_RED as usize] =
        TeamCount(ignoreClientNum, crate::bg_public_h::TEAM_RED);
    if counts[crate::bg_public_h::TEAM_BLUE as usize]
        > counts[crate::bg_public_h::TEAM_RED as usize]
    {
        return crate::bg_public_h::TEAM_RED;
    }
    if counts[crate::bg_public_h::TEAM_RED as usize]
        > counts[crate::bg_public_h::TEAM_BLUE as usize]
    {
        return crate::bg_public_h::TEAM_BLUE;
    }
    // equal team count, so join the team with the lowest score
    if crate::src::game::g_main::level.teamScores[crate::bg_public_h::TEAM_BLUE as usize]
        > crate::src::game::g_main::level.teamScores[crate::bg_public_h::TEAM_RED as usize]
    {
        return crate::bg_public_h::TEAM_RED;
    }
    return crate::bg_public_h::TEAM_BLUE;
}
/*
===========
ForceClientSkin

Forces a client's skin (for teamplay)
===========
*/
/*
static void ForceClientSkin( gclient_t *client, char *model, const char *skin ) {
    char *p;

    if ((p = strrchr(model, '/')) != 0) {
        *p = 0;
    }

    Q_strcat(model, MAX_QPATH, "/");
    Q_strcat(model, MAX_QPATH, skin);
}
*/
/*
===========
ClientCleanName
============
*/

unsafe extern "C" fn ClientCleanName(mut in_0: *const i8, mut out: *mut i8, mut outSize: i32) {
    let mut outpos: i32 = 0;
    let mut colorlessLen: i32 = 0;
    let mut spaces: i32 = 0;
    // discard leading spaces
    while *in_0 as i32 == ' ' as i32 {
        in_0 = in_0.offset(1)
    }
    let mut current_block_12: u64;
    while *in_0 as i32 != 0 && outpos < outSize - 1 {
        *out.offset(outpos as isize) = *in_0;
        if *in_0 as i32 == ' ' as i32 {
            // don't allow too many consecutive spaces
            if spaces > 2 {
                current_block_12 = 4644295000439058019;
            } else {
                spaces += 1;
                current_block_12 = 26972500619410423;
            }
        } else if outpos > 0 && *out.offset((outpos - 1) as isize) as i32 == '^' as i32 {
            if crate::src::qcommon::q_shared::Q_IsColorString(
                &mut *out.offset((outpos - 1) as isize),
            ) as u64
                != 0
            {
                colorlessLen -= 1;
                if *in_0 as i32 - '0' as i32 & 0x7 == 0 {
                    // Disallow color black in names to prevent players
                    // from getting advantage playing in front of black backgrounds
                    outpos -= 1;
                    current_block_12 = 4644295000439058019;
                } else {
                    current_block_12 = 26972500619410423;
                }
            } else {
                spaces = 0;
                colorlessLen += 1;
                current_block_12 = 26972500619410423;
            }
        } else {
            spaces = 0;
            colorlessLen += 1;
            current_block_12 = 26972500619410423;
        }
        match current_block_12 {
            26972500619410423 => outpos += 1,
            _ => {}
        }
        in_0 = in_0.offset(1)
    }
    *out.offset(outpos as isize) = '\u{0}' as i8;
    // don't allow empty names
    if *out as i32 == '\u{0}' as i32 || colorlessLen == 0 {
        crate::src::qcommon::q_shared::Q_strncpyz(
            out,
            b"UnnamedPlayer\x00" as *const u8 as *const i8,
            outSize,
        );
    };
}
/*
===========
ClientUserInfoChanged

Called from ClientConnect when the player first connects and
directly by the server system when the player updates a userinfo variable.

The game can override any of the settings and call trap_SetUserinfo
if desired.
============
*/
#[no_mangle]

pub unsafe extern "C" fn ClientUserinfoChanged(mut clientNum: i32) {
    let mut ent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut teamTask: i32 = 0;
    let mut teamLeader: i32 = 0;
    let mut health: i32 = 0;
    let mut s: *mut i8 = 0 as *mut i8;
    let mut model: [i8; 64] = [0; 64];
    let mut headModel: [i8; 64] = [0; 64];
    let mut oldname: [i8; 1024] = [0; 1024];
    let mut client: *mut crate::g_local_h::gclient_t = 0 as *mut crate::g_local_h::gclient_t;
    let mut c1: [i8; 1024] = [0; 1024];
    let mut c2: [i8; 1024] = [0; 1024];
    let mut redTeam: [i8; 1024] = [0; 1024];
    let mut blueTeam: [i8; 1024] = [0; 1024];
    let mut userinfo: [i8; 1024] = [0; 1024];
    ent = crate::src::game::g_main::g_entities
        .as_mut_ptr()
        .offset(clientNum as isize);
    client = (*ent).client;
    crate::src::game::g_syscalls::trap_GetUserinfo(
        clientNum,
        userinfo.as_mut_ptr(),
        ::std::mem::size_of::<[i8; 1024]>() as i32,
    );
    // check for malformed or illegal info strings
    if crate::src::qcommon::q_shared::Info_Validate(userinfo.as_mut_ptr()) as u64 == 0 {
        crate::stdlib::strcpy(
            userinfo.as_mut_ptr(),
            b"\\name\\badinfo\x00" as *const u8 as *const i8,
        );
        // don't keep those clients and userinfo
        crate::src::game::g_syscalls::trap_DropClient(
            clientNum,
            b"Invalid userinfo\x00" as *const u8 as *const i8,
        );
    }
    // check the item prediction
    s = crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"cg_predictItems\x00" as *const u8 as *const i8,
    );
    if atoi(s) == 0 {
        (*client).pers.predictItemPickup = crate::src::qcommon::q_shared::qfalse
    } else {
        (*client).pers.predictItemPickup = crate::src::qcommon::q_shared::qtrue
    }
    // set name
    crate::src::qcommon::q_shared::Q_strncpyz(
        oldname.as_mut_ptr(),
        (*client).pers.netname.as_mut_ptr(),
        ::std::mem::size_of::<[i8; 1024]>() as i32,
    );
    s = crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"name\x00" as *const u8 as *const i8,
    );
    ClientCleanName(
        s,
        (*client).pers.netname.as_mut_ptr(),
        ::std::mem::size_of::<[i8; 36]>() as i32,
    );
    if (*client).sess.sessionTeam == crate::bg_public_h::TEAM_SPECTATOR {
        if (*client).sess.spectatorState == crate::g_local_h::SPECTATOR_SCOREBOARD {
            crate::src::qcommon::q_shared::Q_strncpyz(
                (*client).pers.netname.as_mut_ptr(),
                b"scoreboard\x00" as *const u8 as *const i8,
                ::std::mem::size_of::<[i8; 36]>() as i32,
            );
        }
    }
    if (*client).pers.connected == crate::g_local_h::CON_CONNECTED {
        if crate::stdlib::strcmp(oldname.as_mut_ptr(), (*client).pers.netname.as_mut_ptr()) != 0 {
            crate::src::game::g_syscalls::trap_SendServerCommand(
                -(1i32),
                crate::src::qcommon::q_shared::va(
                    b"print \"%s^7 renamed to %s\n\"\x00" as *const u8 as *mut i8,
                    oldname.as_mut_ptr(),
                    (*client).pers.netname.as_mut_ptr(),
                ),
            );
        }
    }
    // set max health
    health = atoi(crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"handicap\x00" as *const u8 as *const i8,
    ));
    (*client).pers.maxHealth = health;
    if (*client).pers.maxHealth < 1 || (*client).pers.maxHealth > 100 {
        (*client).pers.maxHealth = 100
    }
    (*client).ps.stats[crate::bg_public_h::STAT_MAX_HEALTH as usize] = (*client).pers.maxHealth;
    // set model
    if crate::src::game::g_main::g_gametype.integer >= crate::bg_public_h::GT_TEAM as i32 {
        crate::src::qcommon::q_shared::Q_strncpyz(
            model.as_mut_ptr(),
            crate::src::qcommon::q_shared::Info_ValueForKey(
                userinfo.as_mut_ptr(),
                b"team_model\x00" as *const u8 as *const i8,
            ),
            ::std::mem::size_of::<[i8; 64]>() as i32,
        );
        crate::src::qcommon::q_shared::Q_strncpyz(
            headModel.as_mut_ptr(),
            crate::src::qcommon::q_shared::Info_ValueForKey(
                userinfo.as_mut_ptr(),
                b"team_headmodel\x00" as *const u8 as *const i8,
            ),
            ::std::mem::size_of::<[i8; 64]>() as i32,
        );
    } else {
        crate::src::qcommon::q_shared::Q_strncpyz(
            model.as_mut_ptr(),
            crate::src::qcommon::q_shared::Info_ValueForKey(
                userinfo.as_mut_ptr(),
                b"model\x00" as *const u8 as *const i8,
            ),
            ::std::mem::size_of::<[i8; 64]>() as i32,
        );
        crate::src::qcommon::q_shared::Q_strncpyz(
            headModel.as_mut_ptr(),
            crate::src::qcommon::q_shared::Info_ValueForKey(
                userinfo.as_mut_ptr(),
                b"headmodel\x00" as *const u8 as *const i8,
            ),
            ::std::mem::size_of::<[i8; 64]>() as i32,
        );
    }
    /*	NOTE: all client side now

        // team
        switch( team ) {
        case TEAM_RED:
            ForceClientSkin(client, model, "red");
    //		ForceClientSkin(client, headModel, "red");
            break;
        case TEAM_BLUE:
            ForceClientSkin(client, model, "blue");
    //		ForceClientSkin(client, headModel, "blue");
            break;
        }
        // don't ever use a default skin in teamplay, it would just waste memory
        // however bots will always join a team but they spawn in as spectator
        if ( g_gametype.integer >= GT_TEAM && team == TEAM_SPECTATOR) {
            ForceClientSkin(client, model, "red");
    //		ForceClientSkin(client, headModel, "red");
        }
    */
    // teamInfo
    s = crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"teamoverlay\x00" as *const u8 as *const i8,
    );
    if *s == 0 || atoi(s) != 0 {
        (*client).pers.teamInfo = crate::src::qcommon::q_shared::qtrue
    } else {
        (*client).pers.teamInfo = crate::src::qcommon::q_shared::qfalse
    }
    /*
    s = Info_ValueForKey( userinfo, "cg_pmove_fixed" );
    if ( !*s || atoi( s ) == 0 ) {
        client->pers.pmoveFixed = qfalse;
    }
    else {
        client->pers.pmoveFixed = qtrue;
    }
    */
    // team task (0 = none, 1 = offence, 2 = defence)
    teamTask = atoi(crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"teamtask\x00" as *const u8 as *const i8,
    ));
    // team Leader (1 = leader, 0 is normal player)
    teamLeader = (*client).sess.teamLeader as i32;
    // colors
    crate::src::qcommon::q_shared::Q_strncpyz(
        c1.as_mut_ptr(),
        crate::src::qcommon::q_shared::Info_ValueForKey(
            userinfo.as_mut_ptr(),
            b"color1\x00" as *const u8 as *const i8,
        ),
        ::std::mem::size_of::<[i8; 1024]>() as i32,
    );
    crate::src::qcommon::q_shared::Q_strncpyz(
        c2.as_mut_ptr(),
        crate::src::qcommon::q_shared::Info_ValueForKey(
            userinfo.as_mut_ptr(),
            b"color2\x00" as *const u8 as *const i8,
        ),
        ::std::mem::size_of::<[i8; 1024]>() as i32,
    );
    crate::src::qcommon::q_shared::Q_strncpyz(
        redTeam.as_mut_ptr(),
        crate::src::qcommon::q_shared::Info_ValueForKey(
            userinfo.as_mut_ptr(),
            b"g_redteam\x00" as *const u8 as *const i8,
        ),
        ::std::mem::size_of::<[i8; 1024]>() as i32,
    );
    crate::src::qcommon::q_shared::Q_strncpyz(
        blueTeam.as_mut_ptr(),
        crate::src::qcommon::q_shared::Info_ValueForKey(
            userinfo.as_mut_ptr(),
            b"g_blueteam\x00" as *const u8 as *const i8,
        ),
        ::std::mem::size_of::<[i8; 1024]>() as i32,
    );
    // send over a subset of the userinfo keys so other clients can
    // print scoreboards, display models, and play custom sounds
    if (*ent).r.svFlags & 0x8 != 0 {
        s =
            crate::src::qcommon::q_shared::va(b"n\\%s\\t\\%i\\model\\%s\\hmodel\\%s\\c1\\%s\\c2\\%s\\hc\\%i\\w\\%i\\l\\%i\\skill\\%s\\tt\\%d\\tl\\%d\x00" as *const  u8 as *mut i8,
               (*client).pers.netname.as_mut_ptr(),
               
               (*client).sess.sessionTeam, model.as_mut_ptr(),
               headModel.as_mut_ptr(), c1.as_mut_ptr(), c2.as_mut_ptr(),
               (*client).pers.maxHealth, (*client).sess.wins,
               (*client).sess.losses,
               crate::src::qcommon::q_shared::Info_ValueForKey(userinfo.as_mut_ptr(),
                                b"skill\x00" as *const u8 as
                                    *const i8), teamTask,
               teamLeader)
    } else {
        s =
            crate::src::qcommon::q_shared::va(b"n\\%s\\t\\%i\\model\\%s\\hmodel\\%s\\g_redteam\\%s\\g_blueteam\\%s\\c1\\%s\\c2\\%s\\hc\\%i\\w\\%i\\l\\%i\\tt\\%d\\tl\\%d\x00" as *const  u8 as *mut i8,
               (*client).pers.netname.as_mut_ptr(),
               
               (*client).sess.sessionTeam, model.as_mut_ptr(),
               headModel.as_mut_ptr(), redTeam.as_mut_ptr(),
               blueTeam.as_mut_ptr(), c1.as_mut_ptr(), c2.as_mut_ptr(),
               (*client).pers.maxHealth, (*client).sess.wins,
               (*client).sess.losses, teamTask, teamLeader)
    }
    crate::src::game::g_syscalls::trap_SetConfigstring(32 + 256 + 256 + clientNum, s);
    // this is not the userinfo, more like the configstring actually
    crate::src::game::g_main::G_LogPrintf(
        b"ClientUserinfoChanged: %i %s\n\x00" as *const u8 as *const i8,
        clientNum,
        s,
    );
}
/*
===========
ClientConnect

Called when a player begins connecting to the server.
Called again for every map change or tournement restart.

The session information will be valid after exit.

Return NULL if the client should be allowed, otherwise return
a string with the reason for denial.

Otherwise, the client will be sent the current gamestate
and will eventually get to ClientBegin.

firstTime will be qtrue the very first time a client connects
to the server machine, but qfalse on map changes and tournement
restarts.
============
*/
#[no_mangle]

pub unsafe extern "C" fn ClientConnect(
    mut clientNum: i32,
    mut firstTime: crate::src::qcommon::q_shared::qboolean,
    mut isBot: crate::src::qcommon::q_shared::qboolean,
) -> *mut i8 {
    let mut value: *mut i8 = 0 as *mut i8;
    //	char		*areabits;
    let mut client: *mut crate::g_local_h::gclient_t = 0 as *mut crate::g_local_h::gclient_t;
    let mut userinfo: [i8; 1024] = [0; 1024];
    let mut ent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    ent = &mut *crate::src::game::g_main::g_entities
        .as_mut_ptr()
        .offset(clientNum as isize) as *mut crate::g_local_h::gentity_t;
    crate::src::game::g_syscalls::trap_GetUserinfo(
        clientNum,
        userinfo.as_mut_ptr(),
        ::std::mem::size_of::<[i8; 1024]>() as i32,
    );
    // IP filtering
    // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=500
    // recommanding PB based IP / GUID banning, the builtin system is pretty limited
    // check to see if they are on the banned IP list
    value = crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"ip\x00" as *const u8 as *const i8,
    );
    if crate::src::game::g_svcmds::G_FilterPacket(value) as u64 != 0 {
        return b"You are banned from this server.\x00" as *const u8 as *mut i8;
    }
    // we don't check password for bots and local client
    // NOTE: local client <-> "ip" "localhost"
    //   this means this client is not running in our current process
    if isBot as u64 == 0
        && crate::stdlib::strcmp(value, b"localhost\x00" as *const u8 as *const i8) != 0
    {
        // check for a password
        value = crate::src::qcommon::q_shared::Info_ValueForKey(
            userinfo.as_mut_ptr(),
            b"password\x00" as *const u8 as *const i8,
        );
        if crate::src::game::g_main::g_password.string[0] as i32 != 0
            && crate::src::qcommon::q_shared::Q_stricmp(
                crate::src::game::g_main::g_password.string.as_mut_ptr(),
                b"none\x00" as *const u8 as *const i8,
            ) != 0
            && crate::stdlib::strcmp(
                crate::src::game::g_main::g_password.string.as_mut_ptr(),
                value,
            ) != 0
        {
            return b"Invalid password\x00" as *const u8 as *mut i8;
        }
    }
    // if a player reconnects quickly after a disconnect, the client disconnect may never be called, thus flag can get lost in the ether
    if (*ent).inuse as u64 != 0 {
        crate::src::game::g_main::G_LogPrintf(
            b"Forcing disconnect on active client: %i\n\x00" as *const u8 as *const i8,
            clientNum,
        );
        // so lets just fix up anything that should happen on a disconnect
        ClientDisconnect(clientNum);
    }
    // they can connect
    (*ent).client = crate::src::game::g_main::level
        .clients
        .offset(clientNum as isize);
    client = (*ent).client;
    //	areabits = client->areabits;
    crate::stdlib::memset(
        client as *mut libc::c_void,
        0,
        ::std::mem::size_of::<crate::g_local_h::gclient_t>(),
    );
    (*client).pers.connected = crate::g_local_h::CON_CONNECTING;
    // check for local client
    value = crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"ip\x00" as *const u8 as *const i8,
    );
    if crate::stdlib::strcmp(value, b"localhost\x00" as *const u8 as *const i8) == 0 {
        (*client).pers.localClient = crate::src::qcommon::q_shared::qtrue
    }
    if isBot as u64 != 0 {
        (*ent).r.svFlags |= 0x8;
        (*ent).inuse = crate::src::qcommon::q_shared::qtrue;
        if crate::src::game::g_bot::G_BotConnect(
            clientNum,
            (firstTime as u64 == 0) as crate::src::qcommon::q_shared::qboolean,
        ) as u64
            == 0
        {
            return b"BotConnectfailed\x00" as *const u8 as *mut i8;
        }
    }
    // read or initialize the session data
    if firstTime != 0 || crate::src::game::g_main::level.newSession != 0 {
        crate::src::game::g_session::G_InitSessionData(client, userinfo.as_mut_ptr());
    }
    crate::src::game::g_session::G_ReadSessionData(client);
    // get and distribute relevant parameters
    crate::src::game::g_main::G_LogPrintf(
        b"ClientConnect: %i\n\x00" as *const u8 as *const i8,
        clientNum,
    );
    ClientUserinfoChanged(clientNum);
    // don't do the "xxx connected" messages if they were caried over from previous level
    if firstTime as u64 != 0 {
        crate::src::game::g_syscalls::trap_SendServerCommand(
            -(1i32),
            crate::src::qcommon::q_shared::va(
                b"print \"%s^7 connected\n\"\x00" as *const u8 as *mut i8,
                (*client).pers.netname.as_mut_ptr(),
            ),
        );
    }
    if crate::src::game::g_main::g_gametype.integer >= crate::bg_public_h::GT_TEAM as i32
        && (*client).sess.sessionTeam != crate::bg_public_h::TEAM_SPECTATOR
    {
        crate::src::game::g_cmds::BroadcastTeamChange(client, -(1i32));
    }
    // count current clients and rank for scoreboard
    crate::src::game::g_main::CalculateRanks();
    // for statistics
    //	client->areabits = areabits;
    //	if ( !client->areabits )
    //		client->areabits = G_Alloc( (trap_AAS_PointReachabilityAreaIndex( NULL ) + 7) / 8 );
    return 0 as *mut i8;
}
/*
===========
ClientBegin

called when a client has finished connecting, and is ready
to be placed into the level.  This will happen every level load,
and on transition between teams, but doesn't happen on respawns
============
*/
#[no_mangle]

pub unsafe extern "C" fn ClientBegin(mut clientNum: i32) {
    let mut ent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut client: *mut crate::g_local_h::gclient_t = 0 as *mut crate::g_local_h::gclient_t;
    let mut flags: i32 = 0;
    ent = crate::src::game::g_main::g_entities
        .as_mut_ptr()
        .offset(clientNum as isize);
    client = crate::src::game::g_main::level
        .clients
        .offset(clientNum as isize);
    if (*ent).r.linked as u64 != 0 {
        crate::src::game::g_syscalls::trap_UnlinkEntity(ent);
    }
    crate::src::game::g_utils::G_InitGentity(ent);
    (*ent).touch = None;
    (*ent).pain = None;
    (*ent).client = client;
    (*client).pers.connected = crate::g_local_h::CON_CONNECTED;
    (*client).pers.enterTime = crate::src::game::g_main::level.time;
    (*client).pers.teamState.state = crate::g_local_h::TEAM_BEGIN;
    // save eflags around this, because changing teams will
    // cause this to happen with a valid entity, and we
    // want to make sure the teleport bit is set right
    // so the viewpoint doesn't interpolate through the
    // world to the new position
    flags = (*client).ps.eFlags;
    crate::stdlib::memset(
        &mut (*client).ps as *mut crate::src::qcommon::q_shared::playerState_t as *mut libc::c_void,
        0,
        ::std::mem::size_of::<crate::src::qcommon::q_shared::playerState_t>(),
    );
    (*client).ps.eFlags = flags;
    // locate ent at a spawn point
    ClientSpawn(ent);
    if (*client).sess.sessionTeam != crate::bg_public_h::TEAM_SPECTATOR {
        if crate::src::game::g_main::g_gametype.integer != crate::bg_public_h::GT_TOURNAMENT as i32
        {
            crate::src::game::g_syscalls::trap_SendServerCommand(
                -(1i32),
                crate::src::qcommon::q_shared::va(
                    b"print \"%s^7 entered the game\n\"\x00" as *const u8 as *mut i8,
                    (*client).pers.netname.as_mut_ptr(),
                ),
            );
        }
    }
    crate::src::game::g_main::G_LogPrintf(
        b"ClientBegin: %i\n\x00" as *const u8 as *const i8,
        clientNum,
    );
    // count current clients and rank for scoreboard
    crate::src::game::g_main::CalculateRanks();
}
/*
===========
ClientSpawn

Called every time a client is placed fresh in the world:
after the first ClientBegin, and after each respawn
Initializes all non-persistant parts of playerState
============
*/
#[no_mangle]

pub unsafe extern "C" fn ClientSpawn(mut ent: *mut crate::g_local_h::gentity_t) {
    let mut index: i32 = 0;
    let mut spawn_origin: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    let mut spawn_angles: crate::src::qcommon::q_shared::vec3_t = [0.; 3];
    let mut client: *mut crate::g_local_h::gclient_t = 0 as *mut crate::g_local_h::gclient_t;
    let mut i: i32 = 0;
    let mut saved: crate::g_local_h::clientPersistant_t = crate::g_local_h::clientPersistant_t {
        connected: crate::g_local_h::CON_DISCONNECTED,
        cmd: crate::src::qcommon::q_shared::usercmd_t {
            serverTime: 0,
            angles: [0; 3],
            buttons: 0,
            weapon: 0,
            forwardmove: 0,
            rightmove: 0,
            upmove: 0,
        },
        localClient: crate::src::qcommon::q_shared::qfalse,
        initialSpawn: crate::src::qcommon::q_shared::qfalse,
        predictItemPickup: crate::src::qcommon::q_shared::qfalse,
        pmoveFixed: crate::src::qcommon::q_shared::qfalse,
        netname: [0; 36],
        maxHealth: 0,
        enterTime: 0,
        teamState: crate::g_local_h::playerTeamState_t {
            state: crate::g_local_h::TEAM_BEGIN,
            location: 0,
            captures: 0,
            basedefense: 0,
            carrierdefense: 0,
            flagrecovery: 0,
            fragcarrier: 0,
            assists: 0,
            lasthurtcarrier: 0.,
            lastreturnedflag: 0.,
            flagsince: 0.,
            lastfraggedcarrier: 0.,
        },
        voteCount: 0,
        teamVoteCount: 0,
        teamInfo: crate::src::qcommon::q_shared::qfalse,
    };
    let mut savedSess: crate::g_local_h::clientSession_t = crate::g_local_h::clientSession_t {
        sessionTeam: crate::bg_public_h::TEAM_FREE,
        spectatorNum: 0,
        spectatorState: crate::g_local_h::SPECTATOR_NOT,
        spectatorClient: 0,
        wins: 0,
        losses: 0,
        teamLeader: crate::src::qcommon::q_shared::qfalse,
    };
    let mut persistant: [i32; 16] = [0; 16];
    let mut spawnPoint: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut tent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut flags: i32 = 0;
    let mut savedPing: i32 = 0;
    //	char	*savedAreaBits;
    let mut accuracy_hits: i32 = 0;
    let mut accuracy_shots: i32 = 0;
    let mut eventSequence: i32 = 0;
    let mut userinfo: [i8; 1024] = [0; 1024];
    index = ent.wrapping_offset_from(crate::src::game::g_main::g_entities.as_mut_ptr()) as i32;
    client = (*ent).client;
    spawn_origin[2] = 0f32;
    spawn_origin[1] = spawn_origin[2];
    spawn_origin[0] = spawn_origin[1];
    // find a spawn point
    // do it before setting health back up, so farthest
    // ranging doesn't count this client
    if (*client).sess.sessionTeam == crate::bg_public_h::TEAM_SPECTATOR {
        spawnPoint = SelectSpectatorSpawnPoint(spawn_origin.as_mut_ptr(), spawn_angles.as_mut_ptr())
    } else if crate::src::game::g_main::g_gametype.integer >= crate::bg_public_h::GT_CTF as i32 {
        // all base oriented team games use the CTF spawn points
        spawnPoint = crate::src::game::g_team::SelectCTFSpawnPoint(
            (*client).sess.sessionTeam,
            (*client).pers.teamState.state as i32,
            spawn_origin.as_mut_ptr(),
            spawn_angles.as_mut_ptr(),
            ((*ent).r.svFlags & 0x8 != 0) as crate::src::qcommon::q_shared::qboolean,
        )
    } else if (*client).pers.initialSpawn as u64 == 0 && (*client).pers.localClient != 0 {
        (*client).pers.initialSpawn = crate::src::qcommon::q_shared::qtrue;
        spawnPoint = SelectInitialSpawnPoint(
            spawn_origin.as_mut_ptr(),
            spawn_angles.as_mut_ptr(),
            ((*ent).r.svFlags & 0x8 != 0) as crate::src::qcommon::q_shared::qboolean,
        )
    } else {
        // the first spawn should be at a good looking spot
        // don't spawn near existing origin if possible
        spawnPoint = SelectSpawnPoint(
            (*client).ps.origin.as_mut_ptr(),
            spawn_origin.as_mut_ptr(),
            spawn_angles.as_mut_ptr(),
            ((*ent).r.svFlags & 0x8 != 0) as crate::src::qcommon::q_shared::qboolean,
        )
    }
    (*client).pers.teamState.state = crate::g_local_h::TEAM_ACTIVE;
    // always clear the kamikaze flag
    (*ent).s.eFlags &= !(0x200);
    // toggle the teleport bit so the client knows to not lerp
    // and never clear the voted flag
    flags = (*(*ent).client).ps.eFlags & (0x4 | 0x4000 | 0x80000);
    flags ^= 0x4;
    // clear everything but the persistant data
    saved = (*client).pers;
    savedSess = (*client).sess;
    savedPing = (*client).ps.ping;
    //	savedAreaBits = client->areabits;
    accuracy_hits = (*client).accuracy_hits;
    accuracy_shots = (*client).accuracy_shots;
    i = 0;
    while i < 16 {
        persistant[i as usize] = (*client).ps.persistant[i as usize];
        i += 1
    }
    eventSequence = (*client).ps.eventSequence;
    crate::stdlib::memset(
        client as *mut libc::c_void,
        0,
        ::std::mem::size_of::<crate::g_local_h::gclient_t>(),
    );
    (*client).pers = saved;
    (*client).sess = savedSess;
    (*client).ps.ping = savedPing;
    //	client->areabits = savedAreaBits;
    (*client).accuracy_hits = accuracy_hits;
    (*client).accuracy_shots = accuracy_shots;
    (*client).lastkilled_client = -(1);
    i = 0;
    while i < 16 {
        (*client).ps.persistant[i as usize] = persistant[i as usize];
        i += 1
    }
    (*client).ps.eventSequence = eventSequence;
    // increment the spawncount so the client will detect the respawn
    (*client).ps.persistant[crate::bg_public_h::PERS_SPAWN_COUNT as usize] += 1;
    (*client).ps.persistant[crate::bg_public_h::PERS_TEAM as usize] =
        (*client).sess.sessionTeam as i32;
    (*client).airOutTime = crate::src::game::g_main::level.time + 12000;
    crate::src::game::g_syscalls::trap_GetUserinfo(
        index,
        userinfo.as_mut_ptr(),
        ::std::mem::size_of::<[i8; 1024]>() as i32,
    );
    // set max health
    (*client).pers.maxHealth = atoi(crate::src::qcommon::q_shared::Info_ValueForKey(
        userinfo.as_mut_ptr(),
        b"handicap\x00" as *const u8 as *const i8,
    ));
    if (*client).pers.maxHealth < 1 || (*client).pers.maxHealth > 100 {
        (*client).pers.maxHealth = 100
    }
    // clear entity values
    (*client).ps.stats[crate::bg_public_h::STAT_MAX_HEALTH as usize] = (*client).pers.maxHealth;
    (*client).ps.eFlags = flags;
    (*ent).s.groundEntityNum = ((1) << 10) - 1;
    (*ent).client = &mut *crate::src::game::g_main::level
        .clients
        .offset(index as isize) as *mut crate::g_local_h::gclient_s;
    (*ent).takedamage = crate::src::qcommon::q_shared::qtrue;
    (*ent).inuse = crate::src::qcommon::q_shared::qtrue;
    (*ent).classname = b"player\x00" as *const u8 as *mut i8;
    (*ent).r.contents = 0x2000000;
    (*ent).clipmask = 1 | 0x10000 | 0x2000000;
    (*ent).die = Some(
        crate::src::game::g_combat::player_die
            as unsafe extern "C" fn(
                _: *mut crate::g_local_h::gentity_t,
                _: *mut crate::g_local_h::gentity_t,
                _: *mut crate::g_local_h::gentity_t,
                _: i32,
                _: i32,
            ) -> (),
    );
    (*ent).waterlevel = 0;
    (*ent).watertype = 0;
    (*ent).flags = 0;
    (*ent).r.mins[0] = playerMins[0];
    (*ent).r.mins[1] = playerMins[1];
    (*ent).r.mins[2] = playerMins[2];
    (*ent).r.maxs[0] = playerMaxs[0];
    (*ent).r.maxs[1] = playerMaxs[1];
    (*ent).r.maxs[2] = playerMaxs[2];
    (*client).ps.clientNum = index;
    (*client).ps.stats[crate::bg_public_h::STAT_WEAPONS as usize] =
        (1) << crate::bg_public_h::WP_MACHINEGUN as i32;
    if crate::src::game::g_main::g_gametype.integer == crate::bg_public_h::GT_TEAM as i32 {
        (*client).ps.ammo[crate::bg_public_h::WP_MACHINEGUN as usize] = 50
    } else {
        (*client).ps.ammo[crate::bg_public_h::WP_MACHINEGUN as usize] = 100
    }
    (*client).ps.stats[crate::bg_public_h::STAT_WEAPONS as usize] |=
        (1) << crate::bg_public_h::WP_GAUNTLET as i32;
    (*client).ps.ammo[crate::bg_public_h::WP_GAUNTLET as usize] = -(1);
    (*client).ps.ammo[crate::bg_public_h::WP_GRAPPLING_HOOK as usize] = -(1);
    // health will count down towards max_health
    (*client).ps.stats[crate::bg_public_h::STAT_HEALTH as usize] =
        (*client).ps.stats[crate::bg_public_h::STAT_MAX_HEALTH as usize] + 25;
    (*ent).health = (*client).ps.stats[crate::bg_public_h::STAT_HEALTH as usize];
    crate::src::game::g_utils::G_SetOrigin(ent, spawn_origin.as_mut_ptr());
    (*client).ps.origin[0] = spawn_origin[0];
    (*client).ps.origin[1] = spawn_origin[1];
    (*client).ps.origin[2] = spawn_origin[2];
    // the respawned flag will be cleared after the attack and jump keys come up
    (*client).ps.pm_flags |= 512;
    crate::src::game::g_syscalls::trap_GetUsercmd(
        client.wrapping_offset_from(crate::src::game::g_main::level.clients) as i32,
        &mut (*(*ent).client).pers.cmd,
    );
    SetClientViewAngle(ent, spawn_angles.as_mut_ptr());
    // don't allow full run speed for a bit
    (*client).ps.pm_flags |= 64;
    (*client).ps.pm_time = 100;
    (*client).respawnTime = crate::src::game::g_main::level.time;
    (*client).inactivityTime = crate::src::game::g_main::level.time
        + crate::src::game::g_main::g_inactivity.integer * 1000;
    (*client).latched_buttons = 0;
    // set default animations
    (*client).ps.torsoAnim = crate::bg_public_h::TORSO_STAND as i32;
    (*client).ps.legsAnim = crate::bg_public_h::LEGS_IDLE as i32;
    if crate::src::game::g_main::level.intermissiontime == 0 {
        if (*(*ent).client).sess.sessionTeam != crate::bg_public_h::TEAM_SPECTATOR {
            crate::src::game::g_utils::G_KillBox(ent);
            // force the base weapon up
            (*client).ps.weapon = crate::bg_public_h::WP_MACHINEGUN as i32;
            (*client).ps.weaponstate = crate::bg_public_h::WEAPON_READY as i32;
            // fire the targets of the spawn point
            crate::src::game::g_utils::G_UseTargets(spawnPoint, ent);
            // select the highest weapon number available, after any spawn given items have fired
            (*client).ps.weapon = 1;
            i = crate::bg_public_h::WP_NUM_WEAPONS as i32 - 1;
            while i > 0 {
                if (*client).ps.stats[crate::bg_public_h::STAT_WEAPONS as usize] & (1) << i != 0 {
                    (*client).ps.weapon = i;
                    break;
                } else {
                    i -= 1
                }
            }
            // positively link the client, even if the command times are weird
            (*ent).r.currentOrigin[0] = (*(*ent).client).ps.origin[0];
            (*ent).r.currentOrigin[1] = (*(*ent).client).ps.origin[1];
            (*ent).r.currentOrigin[2] = (*(*ent).client).ps.origin[2];
            tent = crate::src::game::g_utils::G_TempEntity(
                (*(*ent).client).ps.origin.as_mut_ptr(),
                crate::bg_public_h::EV_PLAYER_TELEPORT_IN as i32,
            );
            (*tent).s.clientNum = (*ent).s.clientNum;
            crate::src::game::g_syscalls::trap_LinkEntity(ent);
        }
    } else {
        // move players to intermission
        crate::src::game::g_main::MoveClientToIntermission(ent);
    }
    // run a client frame to drop exactly to the floor,
    // initialize animations and other things
    (*client).ps.commandTime = crate::src::game::g_main::level.time - 100;
    (*(*ent).client).pers.cmd.serverTime = crate::src::game::g_main::level.time;
    crate::src::game::g_active::ClientThink(
        ent.wrapping_offset_from(crate::src::game::g_main::g_entities.as_mut_ptr()) as i32,
    );
    // run the presend to set anything else, follow spectators wait
    // until all clients have been reconnected after map_restart
    if (*(*ent).client).sess.spectatorState != crate::g_local_h::SPECTATOR_FOLLOW {
        crate::src::game::g_active::ClientEndFrame(ent);
    }
    // clear entity state values
    crate::src::game::bg_misc::BG_PlayerStateToEntityState(
        &mut (*client).ps,
        &mut (*ent).s,
        crate::src::qcommon::q_shared::qtrue,
    );
}
/*
===========================================================================
Copyright (C) 1999-2005 Id Software, Inc.

This file is part of Quake III Arena source code.

Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Quake III Arena source code; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/
//
// g_local.h -- local definitions for game module
//==================================================================
// the "gameversion" client command will print this plus compile date
// msec
// gentity->flags
// not the first on the team
// spawn point not for bot use
// spawn point just for bots
// force gesture on client
// movers are things like doors, plats, buttons, etc
//============================================================================
// communicated by server to clients
// shared by both the server system and game
// DO NOT MODIFY ANYTHING ABOVE THIS, THE SERVER
// EXPECTS THE FIELDS IN THAT ORDER!
//================================
// NULL if not a client
// set in QuakeEd
// set in QuakeEd
// if true, FreeEntity will only unlink
// bodyque uses this
// FL_* variables
// level.time when the object was freed
// events will be cleared EVENT_VALID_MSEC after set
// if true, it can be pushed by movers and fall off edges
// all game items are physicsObjects,
// 1.0 = continuous bounce, 0.0 = no bounce
// brushes with this content value will be collided against
// when moving.  items and corpses do not collide against
// players, for instance
// movers
// body queue sinking, etc
// movers call this when hitting endpoint
// wind tunnel
// quad will increase this without increasing radius
// next entity in team
// master of the team
// timing variables
// for bonus items
// Beginning a team game, spawn at base
// Now actively playing
// client data that stays across multiple levels or tournament restarts
// this is achieved by writing all the data to cvar strings at game shutdown
// time and reading them back at connection time.  Anything added here
// MUST be dealt with in G_InitSessionData() / G_ReadSessionData() / G_WriteSessionData()
// for determining next-in-line to play
// for chasecam and follow mode
// tournament stats
// true when this client is a team leader
//
// client data that stays across multiple respawns, but is cleared
// on each level change or team change at ClientBegin()
// we would lose angles if not persistant
// true if "ip" info key is "localhost"
// the first spawn should be at a cool location
// based on cg_predictItems userinfo
//
// for handicapping
// level.time the client entered the game
// status in teamplay games
// to prevent people from constantly calling votes
// to prevent people from constantly calling votes
// send team overlay updates?
// this structure is cleared on each ClientSpawn(),
// except for 'client->pers' and 'client->sess'
// ps MUST be the first element, because the server expects it
// communicated by server to clients
// the rest of the structure is private to game
// wishes to leave the intermission
// level.time of last usercmd_t, for EF_CONNECTION
// we can't just use pers.lastCommand.time, because
// of the g_sycronousclients case
// sum up damage over an entire frame, so
// shotgun blasts give a single big kick
// damage absorbed by armor
// damage taken out of health
// impact damage
// origin for vector calculation
// if true, don't use the damage_from vector
// for "impressive" reward sound
// total number of shots
// total number of hits
//
// last client that this client killed
// last client that damaged this client
// type of damage the client did
// timers
// can respawn when time > this, force after g_forcerespwan
// kick players when time > this
// qtrue if the five seoond warning has been given
// clear the EF_AWARD_IMPRESSIVE, etc when time > this
// for multiple kill rewards
// used for hook
// grapple hook if out
// time the player switched teams
// timeResidual is used to handle events that happen every second
// like health / armor countdowns and regeneration
//
// this structure is cleared as each map is entered
//
// [maxclients]
// MAX_CLIENTS <= num_entities <= ENTITYNUM_MAX_NORMAL
// restart match at this time
// store latched cvars here that we want to get at often
// in msec
// so movers can back up when blocked
// level.time the map was started
// last time of client team location update
// don't use any old session data, because
// we changed gametype
// waiting for a map_restart to fire
// includes connecting clients
// connected, non-spectators
// sorted by score
// clientNums for auto-follow spectators
// sound index for standing in lava
// for detecting if g_warmup is changed
// voting state
// level.time vote was called
// time the vote is executed
// set by CalculateRanks
// team voting state
// level.time vote was called
// set by CalculateRanks
// spawn variables
// the G_Spawn*() functions are valid
// key / value pairs
// intermission state
// intermission was qualified, but
// wait INTERMISSION_DELAY_TIME before
// actually going there so the last
// frag can be watched.  Disable future
// kills during this delay
// time the intermission was started
// at least one client wants to exit
// also used for spectator spawns
// target_locations get linked
// head of the location list
// dead bodies
//
// g_spawn.c
//
// spawn string returns a temporary reference, you must CopyString() if you want to keep it
//
// g_cmds.c
//
//
// g_items.c
//
//
// g_utils.c
//
//
// g_combat.c
//
// damage flags
// damage was indirect
// armour does not protect from this damage
// do not affect velocity, just view angles
// armor, shields, invulnerability, and godmode have no effect
//
// g_missile.c
//
//
// g_mover.c
//
//
// g_trigger.c
//
//
// g_misc.c
//
//
// g_weapon.c
//
//
// g_client.c
//
//
// g_svcmds.c
//
//
// g_weapon.c
//
//
// g_cmds.c
//
//
// g_main.c
//
//
// g_client.c
//
/*
===========
ClientDisconnect

Called when a player drops from the server.
Will not be called between levels.

This should NOT be called directly by any game logic,
call trap_DropClient(), which will call this and do
server system housekeeping.
============
*/
#[no_mangle]

pub unsafe extern "C" fn ClientDisconnect(mut clientNum: i32) {
    let mut ent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut tent: *mut crate::g_local_h::gentity_t = 0 as *mut crate::g_local_h::gentity_t;
    let mut _i: i32 = 0;
    // cleanup if we are kicking a bot that
    // hasn't spawned yet
    crate::src::game::g_bot::G_RemoveQueuedBotBegin(clientNum);
    ent = crate::src::game::g_main::g_entities
        .as_mut_ptr()
        .offset(clientNum as isize);
    if (*ent).client.is_null()
        || (*(*ent).client).pers.connected == crate::g_local_h::CON_DISCONNECTED
    {
        return;
    }
    // stop any following clients

    for i in 0..crate::src::game::g_main::level.maxclients {
        if (*crate::src::game::g_main::level.clients.offset(i as isize))
            .sess
            .sessionTeam
            == crate::bg_public_h::TEAM_SPECTATOR
            && (*crate::src::game::g_main::level.clients.offset(i as isize))
                .sess
                .spectatorState
                == crate::g_local_h::SPECTATOR_FOLLOW
            && (*crate::src::game::g_main::level.clients.offset(i as isize))
                .sess
                .spectatorClient
                == clientNum
        {
            crate::src::game::g_cmds::StopFollowing(
                &mut *crate::src::game::g_main::g_entities
                    .as_mut_ptr()
                    .offset(i as isize),
            );
        }
    }
    // send effect if they were completely connected
    if (*(*ent).client).pers.connected == crate::g_local_h::CON_CONNECTED
        && (*(*ent).client).sess.sessionTeam != crate::bg_public_h::TEAM_SPECTATOR
    {
        tent = crate::src::game::g_utils::G_TempEntity(
            (*(*ent).client).ps.origin.as_mut_ptr(),
            crate::bg_public_h::EV_PLAYER_TELEPORT_OUT as i32,
        );
        (*tent).s.clientNum = (*ent).s.clientNum;
        // They don't get to take powerups with them!
        // Especially important for stuff like CTF flags
        crate::src::game::g_combat::TossClientItems(ent);
    }
    crate::src::game::g_main::G_LogPrintf(
        b"ClientDisconnect: %i\n\x00" as *const u8 as *const i8,
        clientNum,
    );
    // if we are playing in tourney mode and losing, give a win to the other player
    if crate::src::game::g_main::g_gametype.integer == crate::bg_public_h::GT_TOURNAMENT as i32
        && crate::src::game::g_main::level.intermissiontime == 0
        && crate::src::game::g_main::level.warmupTime == 0
        && crate::src::game::g_main::level.sortedClients[1] == clientNum
    {
        let ref mut fresh3 = (*crate::src::game::g_main::level
            .clients
            .offset(crate::src::game::g_main::level.sortedClients[0] as isize))
        .sess
        .wins;
        *fresh3 += 1;
        ClientUserinfoChanged(crate::src::game::g_main::level.sortedClients[0usize]);
    }
    if crate::src::game::g_main::g_gametype.integer == crate::bg_public_h::GT_TOURNAMENT as i32
        && (*(*ent).client).sess.sessionTeam == crate::bg_public_h::TEAM_FREE
        && crate::src::game::g_main::level.intermissiontime != 0
    {
        crate::src::game::g_syscalls::trap_SendConsoleCommand(
            crate::src::qcommon::q_shared::EXEC_APPEND as i32,
            b"map_restart 0\n\x00" as *const u8 as *const i8,
        );
        crate::src::game::g_main::level.restarted = crate::src::qcommon::q_shared::qtrue;
        crate::src::game::g_main::level.changemap = 0 as *mut i8;
        crate::src::game::g_main::level.intermissiontime = 0
    }
    crate::src::game::g_syscalls::trap_UnlinkEntity(ent);
    (*ent).s.modelindex = 0;
    (*ent).inuse = crate::src::qcommon::q_shared::qfalse;
    (*ent).classname = b"disconnected\x00" as *const u8 as *mut i8;
    (*(*ent).client).pers.connected = crate::g_local_h::CON_DISCONNECTED;
    (*(*ent).client).ps.persistant[crate::bg_public_h::PERS_TEAM as usize] =
        crate::bg_public_h::TEAM_FREE as i32;
    (*(*ent).client).sess.sessionTeam = crate::bg_public_h::TEAM_FREE;
    crate::src::game::g_syscalls::trap_SetConfigstring(
        32 + 256 + 256 + clientNum,
        b"\x00" as *const u8 as *const i8,
    );
    crate::src::game::g_main::CalculateRanks();
    if (*ent).r.svFlags & 0x8 != 0 {
        crate::src::game::ai_main::BotAIShutdownClient(
            clientNum,
            crate::src::qcommon::q_shared::qfalse,
        );
    };
}
